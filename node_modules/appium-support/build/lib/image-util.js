"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cropBase64Image = cropBase64Image;
exports.base64ToImage = base64ToImage;
exports.imageToBase64 = imageToBase64;
exports.cropImage = cropImage;
exports.getImagesMatches = getImagesMatches;
exports.getImagesSimilarity = getImagesSimilarity;
exports.getImageOccurrence = getImageOccurrence;
exports.getJimpImage = getJimpImage;
exports.MIME_BMP = exports.MIME_PNG = exports.MIME_JPEG = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _jimp = _interopRequireDefault(require("jimp"));

var _buffer = require("buffer");

var _pngjs = require("pngjs");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _util = require("./util");

var _logger = _interopRequireDefault(require("./logger"));

var _node = require("./node");

const {
  MIME_JPEG,
  MIME_PNG,
  MIME_BMP
} = _jimp.default;
exports.MIME_BMP = MIME_BMP;
exports.MIME_PNG = MIME_PNG;
exports.MIME_JPEG = MIME_JPEG;
let cv = null;
const BYTES_IN_PIXEL_BLOCK = 4;
const SCANLINE_FILTER_METHOD = 4;
const DEFAULT_MATCH_THRESHOLD = 0.5;
const MATCH_NEIGHBOUR_THRESHOLD = 10;
const AVAILABLE_DETECTORS = ['AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB'];
const AVAILABLE_MATCHING_FUNCTIONS = ['FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2'];

async function getJimpImage(data) {
  return await new _bluebird.default((resolve, reject) => {
    if (!_lodash.default.isString(data) && !_lodash.default.isBuffer(data)) {
      return reject(new Error('Must initialize jimp object with string or buffer'));
    }

    if (_lodash.default.isString(data)) {
      data = _buffer.Buffer.from(data, 'base64');
    }

    new _jimp.default(data, (err, imgObj) => {
      if (err) {
        return reject(err);
      }

      if (!imgObj) {
        return reject(new Error('Could not create jimp image from that data'));
      }

      imgObj._getBuffer = imgObj.getBuffer.bind(imgObj);
      imgObj.getBuffer = _bluebird.default.promisify(imgObj._getBuffer, {
        context: imgObj
      });
      resolve(imgObj);
    });
  });
}

async function initOpenCV() {
  if (cv) {
    return;
  }

  _logger.default.debug(`Initializing opencv`);

  try {
    cv = await (0, _node.requirePackage)('opencv4nodejs');
  } catch (err) {
    _logger.default.warn(`Unable to load 'opencv4nodejs': ${err.message}`);
  }

  if (!cv) {
    throw new Error(`'opencv4nodejs' module is required to use OpenCV features. ` + `Please install it first ('npm i -g opencv4nodejs') and restart Appium. ` + 'Read https://github.com/justadudewhohacks/opencv4nodejs#how-to-install for more details on this topic.');
  }
}

async function detectAndCompute(img, detector) {
  const keyPoints = await detector.detectAsync(img);
  const descriptor = await detector.computeAsync(img, keyPoints);
  return {
    keyPoints,
    descriptor
  };
}

function calculateMatchedRect(matchedPoints) {
  if (matchedPoints.length < 2) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  const pointsSortedByDistance = matchedPoints.map(point => [Math.sqrt(point.x * point.x + point.y * point.y), point]).sort((pair1, pair2) => pair1[0] >= pair2[0]).map(pair => pair[1]);

  const firstPoint = _lodash.default.head(pointsSortedByDistance);

  const lastPoint = _lodash.default.last(pointsSortedByDistance);

  const topLeftPoint = {
    x: firstPoint.x <= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y <= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  const bottomRightPoint = {
    x: firstPoint.x >= lastPoint.x ? firstPoint.x : lastPoint.x,
    y: firstPoint.y >= lastPoint.y ? firstPoint.y : lastPoint.y
  };
  return {
    x: topLeftPoint.x,
    y: topLeftPoint.y,
    width: bottomRightPoint.x - topLeftPoint.x,
    height: bottomRightPoint.y - topLeftPoint.y
  };
}

function highlightRegion(mat, region) {
  if (region.width <= 0 || region.height <= 0) {
    return;
  }

  const color = new cv.Vec(0, 0, 255);
  const thickness = 2;
  mat.drawRectangle(new cv.Rect(region.x, region.y, region.width, region.height), color, thickness, cv.LINE_8);
  return mat;
}

async function getImagesMatches(img1Data, img2Data, options = {}) {
  await initOpenCV();
  const {
    detectorName = 'ORB',
    visualize = false,
    goodMatchesFactor,
    matchFunc = 'BruteForce'
  } = options;

  if (!_lodash.default.includes(AVAILABLE_DETECTORS, detectorName)) {
    throw new Error(`'${detectorName}' detector is unknown. ` + `Only ${JSON.stringify(AVAILABLE_DETECTORS)} detectors are supported.`);
  }

  if (!_lodash.default.includes(AVAILABLE_MATCHING_FUNCTIONS, matchFunc)) {
    throw new Error(`'${matchFunc}' matching function is unknown. ` + `Only ${JSON.stringify(AVAILABLE_MATCHING_FUNCTIONS)} matching functions are supported.`);
  }

  const detector = new cv[`${detectorName}Detector`]();
  const [img1, img2] = await _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]);
  const [result1, result2] = await _bluebird.default.all([detectAndCompute(img1, detector), detectAndCompute(img2, detector)]);
  let matches = [];

  try {
    matches = await cv[`match${matchFunc}Async`](result1.descriptor, result2.descriptor);
  } catch (e) {
    throw new Error(`Cannot find any matches between the given images. Try another detection algorithm. ` + ` Original error: ${e}`);
  }

  const totalCount = matches.length;

  if ((0, _util.hasValue)(goodMatchesFactor)) {
    if (_lodash.default.isFunction(goodMatchesFactor)) {
      const distances = matches.map(match => match.distance);

      const minDistance = _lodash.default.min(distances);

      const maxDistance = _lodash.default.max(distances);

      matches = matches.filter(match => goodMatchesFactor(match.distance, minDistance, maxDistance));
    } else {
      if (matches.length > goodMatchesFactor) {
        matches = matches.sort((match1, match2) => match1.distance - match2.distance).slice(0, goodMatchesFactor);
      }
    }
  }

  const extractPoint = (keyPoints, indexPropertyName) => match => {
    const {
      pt,
      point
    } = keyPoints[match[indexPropertyName]];
    return pt || point;
  };

  const points1 = matches.map(extractPoint(result1.keyPoints, 'queryIdx'));
  const rect1 = calculateMatchedRect(points1);
  const points2 = matches.map(extractPoint(result2.keyPoints, 'trainIdx'));
  const rect2 = calculateMatchedRect(points2);
  const result = {
    points1,
    rect1,
    points2,
    rect2,
    totalCount,
    count: matches.length
  };

  if (visualize) {
    const visualization = cv.drawMatches(img1, img2, result1.keyPoints, result2.keyPoints, matches);
    highlightRegion(visualization, rect1);
    highlightRegion(visualization, {
      x: img1.cols + rect2.x,
      y: rect2.y,
      width: rect2.width,
      height: rect2.height
    });
    result.visualization = await cv.imencodeAsync('.png', visualization);
  }

  return result;
}

async function getImagesSimilarity(img1Data, img2Data, options = {}) {
  await initOpenCV();
  const {
    visualize = false
  } = options;
  let [template, reference] = await _bluebird.default.all([cv.imdecodeAsync(img1Data), cv.imdecodeAsync(img2Data)]);

  if (template.rows !== reference.rows || template.cols !== reference.cols) {
    throw new Error('Both images are expected to have the same size in order to ' + 'calculate the similarity score.');
  }

  [template, reference] = await _bluebird.default.all([template.convertToAsync(cv.CV_8UC3), reference.convertToAsync(cv.CV_8UC3)]);
  const matched = await reference.matchTemplateAsync(template, cv.TM_CCOEFF_NORMED);
  const minMax = await matched.minMaxLocAsync();
  const result = {
    score: minMax.maxVal
  };

  if (visualize) {
    const resultMat = new cv.Mat(template.rows, template.cols * 2, cv.CV_8UC3);
    await _bluebird.default.all([reference.copyToAsync(resultMat.getRegion(new cv.Rect(0, 0, reference.cols, reference.rows))), template.copyToAsync(resultMat.getRegion(new cv.Rect(reference.cols, 0, template.cols, template.rows)))]);
    let mask = reference.absdiff(template);
    mask = await mask.cvtColorAsync(cv.COLOR_BGR2GRAY);
    let contours = [];

    try {
      mask = await mask.thresholdAsync(128, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
      contours = await mask.findContoursAsync(cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    } catch (ign) {}

    for (const contour of contours) {
      const boundingRect = contour.boundingRect();
      highlightRegion(resultMat, boundingRect);
      highlightRegion(resultMat, {
        x: reference.cols + boundingRect.x,
        y: boundingRect.y,
        width: boundingRect.width,
        height: boundingRect.height
      });
    }

    result.visualization = await cv.imencodeAsync('.png', resultMat);
  }

  return result;
}

async function getImageOccurrence(fullImgData, partialImgData, options = {}) {
  await initOpenCV();
  const {
    visualize = false,
    threshold = DEFAULT_MATCH_THRESHOLD,
    multiple = false,
    matchNeighbourThreshold = MATCH_NEIGHBOUR_THRESHOLD
  } = options;
  const [fullImg, partialImg] = await _bluebird.default.all([cv.imdecodeAsync(fullImgData), cv.imdecodeAsync(partialImgData)]);
  const results = [];
  let visualization = null;

  try {
    const matched = await fullImg.matchTemplateAsync(partialImg, cv.TM_CCOEFF_NORMED);
    const minMax = await matched.minMaxLocAsync();

    if (multiple) {
      const nonZeroMatchResults = matched.threshold(threshold, 1, cv.THRESH_BINARY).convertTo(cv.CV_8U).findNonZero();
      const matches = filterNearMatches(nonZeroMatchResults, matchNeighbourThreshold);

      for (const element of matches) {
        results.push({
          score: matched.at(element.y, element.x),
          rect: {
            x: element.x,
            y: element.y,
            width: partialImg.cols,
            height: partialImg.rows
          }
        });
      }
    } else if (minMax.maxVal >= threshold) {
      results.push({
        score: minMax.maxVal,
        rect: {
          x: minMax.maxLoc.x,
          y: minMax.maxLoc.y,
          width: partialImg.cols,
          height: partialImg.rows
        }
      });
    }

    if (_lodash.default.isEmpty(results)) {
      throw new Error(`Match threshold: ${threshold}. Highest match value ` + `found was ${minMax.maxVal}`);
    }
  } catch (e) {
    throw new Error(`Cannot find any occurrences of the partial image in the full image. ` + `Original error: ${e.message}`);
  }

  if (visualize) {
    const fullHighlightedImage = fullImg.copy();

    for (const result of results) {
      const singleHighlightedImage = fullImg.copy();
      highlightRegion(singleHighlightedImage, result.rect);
      highlightRegion(fullHighlightedImage, result.rect);
      result.visualization = await cv.imencodeAsync('.png', singleHighlightedImage);
    }

    visualization = await cv.imencodeAsync('.png', fullHighlightedImage);
  }

  return {
    rect: results[0].rect,
    score: results[0].score,
    visualization,
    multiple: results
  };
}

function filterNearMatches(nonZeroMatchResults, matchNeighbourThreshold) {
  return nonZeroMatchResults.reduce((acc, element) => {
    if (!acc.some(match => distance(match, element) <= matchNeighbourThreshold)) {
      acc.push(element);
    }

    return acc;
  }, []);
}

function distance(point1, point2) {
  const a2 = Math.pow(point1.x - point2.x, 2);
  const b2 = Math.pow(point1.y - point2.y, 2);
  return Math.sqrt(a2 + b2);
}

async function cropBase64Image(base64Image, rect) {
  const image = await base64ToImage(base64Image);
  cropImage(image, rect);
  return await imageToBase64(image);
}

async function base64ToImage(base64Image) {
  const imageBuffer = _buffer.Buffer.from(base64Image, 'base64');

  return await new _bluebird.default((resolve, reject) => {
    const image = new _pngjs.PNG({
      filterType: SCANLINE_FILTER_METHOD
    });
    image.parse(imageBuffer, (err, image) => {
      if (err) {
        return reject(err);
      }

      resolve(image);
    });
  });
}

async function imageToBase64(image) {
  return await new _bluebird.default((resolve, reject) => {
    const chunks = [];
    image.pack().on('data', chunk => chunks.push(chunk)).on('end', () => {
      resolve(_buffer.Buffer.concat(chunks).toString('base64'));
    }).on('error', err => {
      reject(err);
    });
  });
}

function cropImage(image, rect) {
  const imageRect = {
    width: image.width,
    height: image.height
  };
  const interRect = getRectIntersection(rect, imageRect);

  if (interRect.width < rect.width || interRect.height < rect.height) {
    throw new Error(`Cannot crop ${JSON.stringify(rect)} from ${JSON.stringify(imageRect)} because the intersection between them was not the size of the rect`);
  }

  const firstVerticalPixel = interRect.top;
  const lastVerticalPixel = interRect.top + interRect.height;
  const firstHorizontalPixel = interRect.left;
  const lastHorizontalPixel = interRect.left + interRect.width;
  const croppedArray = [];

  for (let y = firstVerticalPixel; y < lastVerticalPixel; y++) {
    for (let x = firstHorizontalPixel; x < lastHorizontalPixel; x++) {
      const firstByteIdxInPixelBlock = imageRect.width * y + x << 2;

      for (let byteIdx = 0; byteIdx < BYTES_IN_PIXEL_BLOCK; byteIdx++) {
        croppedArray.push(image.data[firstByteIdxInPixelBlock + byteIdx]);
      }
    }
  }

  image.data = _buffer.Buffer.from(croppedArray);
  image.width = interRect.width;
  image.height = interRect.height;
  return image;
}

function getRectIntersection(rect, imageSize) {
  const left = rect.left >= imageSize.width ? imageSize.width : rect.left;
  const top = rect.top >= imageSize.height ? imageSize.height : rect.top;
  const width = imageSize.width >= left + rect.width ? rect.width : imageSize.width - left;
  const height = imageSize.height >= top + rect.height ? rect.height : imageSize.height - top;
  return {
    left,
    top,
    width,
    height
  };
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9pbWFnZS11dGlsLmpzIl0sIm5hbWVzIjpbIk1JTUVfSlBFRyIsIk1JTUVfUE5HIiwiTUlNRV9CTVAiLCJKaW1wIiwiY3YiLCJCWVRFU19JTl9QSVhFTF9CTE9DSyIsIlNDQU5MSU5FX0ZJTFRFUl9NRVRIT0QiLCJERUZBVUxUX01BVENIX1RIUkVTSE9MRCIsIk1BVENIX05FSUdIQk9VUl9USFJFU0hPTEQiLCJBVkFJTEFCTEVfREVURUNUT1JTIiwiQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OUyIsImdldEppbXBJbWFnZSIsImRhdGEiLCJCIiwicmVzb2x2ZSIsInJlamVjdCIsIl8iLCJpc1N0cmluZyIsImlzQnVmZmVyIiwiRXJyb3IiLCJCdWZmZXIiLCJmcm9tIiwiZXJyIiwiaW1nT2JqIiwiX2dldEJ1ZmZlciIsImdldEJ1ZmZlciIsImJpbmQiLCJwcm9taXNpZnkiLCJjb250ZXh0IiwiaW5pdE9wZW5DViIsImxvZyIsImRlYnVnIiwid2FybiIsIm1lc3NhZ2UiLCJkZXRlY3RBbmRDb21wdXRlIiwiaW1nIiwiZGV0ZWN0b3IiLCJrZXlQb2ludHMiLCJkZXRlY3RBc3luYyIsImRlc2NyaXB0b3IiLCJjb21wdXRlQXN5bmMiLCJjYWxjdWxhdGVNYXRjaGVkUmVjdCIsIm1hdGNoZWRQb2ludHMiLCJsZW5ndGgiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwicG9pbnRzU29ydGVkQnlEaXN0YW5jZSIsIm1hcCIsInBvaW50IiwiTWF0aCIsInNxcnQiLCJzb3J0IiwicGFpcjEiLCJwYWlyMiIsInBhaXIiLCJmaXJzdFBvaW50IiwiaGVhZCIsImxhc3RQb2ludCIsImxhc3QiLCJ0b3BMZWZ0UG9pbnQiLCJib3R0b21SaWdodFBvaW50IiwiaGlnaGxpZ2h0UmVnaW9uIiwibWF0IiwicmVnaW9uIiwiY29sb3IiLCJWZWMiLCJ0aGlja25lc3MiLCJkcmF3UmVjdGFuZ2xlIiwiUmVjdCIsIkxJTkVfOCIsImdldEltYWdlc01hdGNoZXMiLCJpbWcxRGF0YSIsImltZzJEYXRhIiwib3B0aW9ucyIsImRldGVjdG9yTmFtZSIsInZpc3VhbGl6ZSIsImdvb2RNYXRjaGVzRmFjdG9yIiwibWF0Y2hGdW5jIiwiaW5jbHVkZXMiLCJKU09OIiwic3RyaW5naWZ5IiwiaW1nMSIsImltZzIiLCJhbGwiLCJpbWRlY29kZUFzeW5jIiwicmVzdWx0MSIsInJlc3VsdDIiLCJtYXRjaGVzIiwiZSIsInRvdGFsQ291bnQiLCJpc0Z1bmN0aW9uIiwiZGlzdGFuY2VzIiwibWF0Y2giLCJkaXN0YW5jZSIsIm1pbkRpc3RhbmNlIiwibWluIiwibWF4RGlzdGFuY2UiLCJtYXgiLCJmaWx0ZXIiLCJtYXRjaDEiLCJtYXRjaDIiLCJzbGljZSIsImV4dHJhY3RQb2ludCIsImluZGV4UHJvcGVydHlOYW1lIiwicHQiLCJwb2ludHMxIiwicmVjdDEiLCJwb2ludHMyIiwicmVjdDIiLCJyZXN1bHQiLCJjb3VudCIsInZpc3VhbGl6YXRpb24iLCJkcmF3TWF0Y2hlcyIsImNvbHMiLCJpbWVuY29kZUFzeW5jIiwiZ2V0SW1hZ2VzU2ltaWxhcml0eSIsInRlbXBsYXRlIiwicmVmZXJlbmNlIiwicm93cyIsImNvbnZlcnRUb0FzeW5jIiwiQ1ZfOFVDMyIsIm1hdGNoZWQiLCJtYXRjaFRlbXBsYXRlQXN5bmMiLCJUTV9DQ09FRkZfTk9STUVEIiwibWluTWF4IiwibWluTWF4TG9jQXN5bmMiLCJzY29yZSIsIm1heFZhbCIsInJlc3VsdE1hdCIsIk1hdCIsImNvcHlUb0FzeW5jIiwiZ2V0UmVnaW9uIiwibWFzayIsImFic2RpZmYiLCJjdnRDb2xvckFzeW5jIiwiQ09MT1JfQkdSMkdSQVkiLCJjb250b3VycyIsInRocmVzaG9sZEFzeW5jIiwiVEhSRVNIX0JJTkFSWSIsIlRIUkVTSF9PVFNVIiwiZmluZENvbnRvdXJzQXN5bmMiLCJSRVRSX0VYVEVSTkFMIiwiQ0hBSU5fQVBQUk9YX1NJTVBMRSIsImlnbiIsImNvbnRvdXIiLCJib3VuZGluZ1JlY3QiLCJnZXRJbWFnZU9jY3VycmVuY2UiLCJmdWxsSW1nRGF0YSIsInBhcnRpYWxJbWdEYXRhIiwidGhyZXNob2xkIiwibXVsdGlwbGUiLCJtYXRjaE5laWdoYm91clRocmVzaG9sZCIsImZ1bGxJbWciLCJwYXJ0aWFsSW1nIiwicmVzdWx0cyIsIm5vblplcm9NYXRjaFJlc3VsdHMiLCJjb252ZXJ0VG8iLCJDVl84VSIsImZpbmROb25aZXJvIiwiZmlsdGVyTmVhck1hdGNoZXMiLCJlbGVtZW50IiwicHVzaCIsImF0IiwicmVjdCIsIm1heExvYyIsImlzRW1wdHkiLCJmdWxsSGlnaGxpZ2h0ZWRJbWFnZSIsImNvcHkiLCJzaW5nbGVIaWdobGlnaHRlZEltYWdlIiwicmVkdWNlIiwiYWNjIiwic29tZSIsInBvaW50MSIsInBvaW50MiIsImEyIiwicG93IiwiYjIiLCJjcm9wQmFzZTY0SW1hZ2UiLCJiYXNlNjRJbWFnZSIsImltYWdlIiwiYmFzZTY0VG9JbWFnZSIsImNyb3BJbWFnZSIsImltYWdlVG9CYXNlNjQiLCJpbWFnZUJ1ZmZlciIsIlBORyIsImZpbHRlclR5cGUiLCJwYXJzZSIsImNodW5rcyIsInBhY2siLCJvbiIsImNodW5rIiwiY29uY2F0IiwidG9TdHJpbmciLCJpbWFnZVJlY3QiLCJpbnRlclJlY3QiLCJnZXRSZWN0SW50ZXJzZWN0aW9uIiwiZmlyc3RWZXJ0aWNhbFBpeGVsIiwidG9wIiwibGFzdFZlcnRpY2FsUGl4ZWwiLCJmaXJzdEhvcml6b250YWxQaXhlbCIsImxlZnQiLCJsYXN0SG9yaXpvbnRhbFBpeGVsIiwiY3JvcHBlZEFycmF5IiwiZmlyc3RCeXRlSWR4SW5QaXhlbEJsb2NrIiwiYnl0ZUlkeCIsImltYWdlU2l6ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLE1BQU07QUFBRUEsRUFBQUEsU0FBRjtBQUFhQyxFQUFBQSxRQUFiO0FBQXVCQyxFQUFBQTtBQUF2QixJQUFvQ0MsYUFBMUM7Ozs7QUFDQSxJQUFJQyxFQUFFLEdBQUcsSUFBVDtBQXdCQSxNQUFNQyxvQkFBb0IsR0FBRyxDQUE3QjtBQUNBLE1BQU1DLHNCQUFzQixHQUFHLENBQS9CO0FBQ0EsTUFBTUMsdUJBQXVCLEdBQUcsR0FBaEM7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxFQUFsQztBQUVBLE1BQU1DLG1CQUFtQixHQUFHLENBQzFCLE9BRDBCLEVBRTFCLE9BRjBCLEVBRzFCLE9BSDBCLEVBSTFCLE1BSjBCLEVBSzFCLE1BTDBCLEVBTTFCLE1BTjBCLEVBTzFCLE1BUDBCLEVBUTFCLE1BUjBCLEVBUzFCLEtBVDBCLENBQTVCO0FBWUEsTUFBTUMsNEJBQTRCLEdBQUcsQ0FDbkMsWUFEbUMsRUFFbkMsWUFGbUMsRUFHbkMsY0FIbUMsRUFJbkMsbUJBSm1DLEVBS25DLHNCQUxtQyxFQU1uQyxlQU5tQyxDQUFyQzs7QUFrQkEsZUFBZUMsWUFBZixDQUE2QkMsSUFBN0IsRUFBbUM7QUFDakMsU0FBTyxNQUFNLElBQUlDLGlCQUFKLENBQU0sQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDLFFBQUksQ0FBQ0MsZ0JBQUVDLFFBQUYsQ0FBV0wsSUFBWCxDQUFELElBQXFCLENBQUNJLGdCQUFFRSxRQUFGLENBQVdOLElBQVgsQ0FBMUIsRUFBNEM7QUFDMUMsYUFBT0csTUFBTSxDQUFDLElBQUlJLEtBQUosQ0FBVSxtREFBVixDQUFELENBQWI7QUFDRDs7QUFFRCxRQUFJSCxnQkFBRUMsUUFBRixDQUFXTCxJQUFYLENBQUosRUFBc0I7QUFDcEJBLE1BQUFBLElBQUksR0FBR1EsZUFBT0MsSUFBUCxDQUFZVCxJQUFaLEVBQWtCLFFBQWxCLENBQVA7QUFDRDs7QUFDRCxRQUFJVCxhQUFKLENBQVNTLElBQVQsRUFBZSxDQUFDVSxHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDOUIsVUFBSUQsR0FBSixFQUFTO0FBQ1AsZUFBT1AsTUFBTSxDQUFDTyxHQUFELENBQWI7QUFDRDs7QUFDRCxVQUFJLENBQUNDLE1BQUwsRUFBYTtBQUNYLGVBQU9SLE1BQU0sQ0FBQyxJQUFJSSxLQUFKLENBQVUsNENBQVYsQ0FBRCxDQUFiO0FBQ0Q7O0FBQ0RJLE1BQUFBLE1BQU0sQ0FBQ0MsVUFBUCxHQUFvQkQsTUFBTSxDQUFDRSxTQUFQLENBQWlCQyxJQUFqQixDQUFzQkgsTUFBdEIsQ0FBcEI7QUFDQUEsTUFBQUEsTUFBTSxDQUFDRSxTQUFQLEdBQW1CWixrQkFBRWMsU0FBRixDQUFZSixNQUFNLENBQUNDLFVBQW5CLEVBQStCO0FBQUNJLFFBQUFBLE9BQU8sRUFBRUw7QUFBVixPQUEvQixDQUFuQjtBQUNBVCxNQUFBQSxPQUFPLENBQUNTLE1BQUQsQ0FBUDtBQUNELEtBVkQ7QUFXRCxHQW5CWSxDQUFiO0FBb0JEOztBQUtELGVBQWVNLFVBQWYsR0FBNkI7QUFDM0IsTUFBSXpCLEVBQUosRUFBUTtBQUNOO0FBQ0Q7O0FBRUQwQixrQkFBSUMsS0FBSixDQUFXLHFCQUFYOztBQUNBLE1BQUk7QUFDRjNCLElBQUFBLEVBQUUsR0FBRyxNQUFNLDBCQUFlLGVBQWYsQ0FBWDtBQUNELEdBRkQsQ0FFRSxPQUFPa0IsR0FBUCxFQUFZO0FBQ1pRLG9CQUFJRSxJQUFKLENBQVUsbUNBQWtDVixHQUFHLENBQUNXLE9BQVEsRUFBeEQ7QUFDRDs7QUFFRCxNQUFJLENBQUM3QixFQUFMLEVBQVM7QUFDUCxVQUFNLElBQUllLEtBQUosQ0FBVyw2REFBRCxHQUNDLHlFQURELEdBRUEsd0dBRlYsQ0FBTjtBQUdEO0FBQ0Y7O0FBbUJELGVBQWVlLGdCQUFmLENBQWlDQyxHQUFqQyxFQUFzQ0MsUUFBdEMsRUFBZ0Q7QUFDOUMsUUFBTUMsU0FBUyxHQUFHLE1BQU1ELFFBQVEsQ0FBQ0UsV0FBVCxDQUFxQkgsR0FBckIsQ0FBeEI7QUFDQSxRQUFNSSxVQUFVLEdBQUcsTUFBTUgsUUFBUSxDQUFDSSxZQUFULENBQXNCTCxHQUF0QixFQUEyQkUsU0FBM0IsQ0FBekI7QUFDQSxTQUFPO0FBQ0xBLElBQUFBLFNBREs7QUFFTEUsSUFBQUE7QUFGSyxHQUFQO0FBSUQ7O0FBU0QsU0FBU0Usb0JBQVQsQ0FBK0JDLGFBQS9CLEVBQThDO0FBQzVDLE1BQUlBLGFBQWEsQ0FBQ0MsTUFBZCxHQUF1QixDQUEzQixFQUE4QjtBQUM1QixXQUFPO0FBQ0xDLE1BQUFBLENBQUMsRUFBRSxDQURFO0FBRUxDLE1BQUFBLENBQUMsRUFBRSxDQUZFO0FBR0xDLE1BQUFBLEtBQUssRUFBRSxDQUhGO0FBSUxDLE1BQUFBLE1BQU0sRUFBRTtBQUpILEtBQVA7QUFNRDs7QUFFRCxRQUFNQyxzQkFBc0IsR0FBR04sYUFBYSxDQUN6Q08sR0FENEIsQ0FDdkJDLEtBQUQsSUFBVyxDQUFDQyxJQUFJLENBQUNDLElBQUwsQ0FBVUYsS0FBSyxDQUFDTixDQUFOLEdBQVVNLEtBQUssQ0FBQ04sQ0FBaEIsR0FBb0JNLEtBQUssQ0FBQ0wsQ0FBTixHQUFVSyxLQUFLLENBQUNMLENBQTlDLENBQUQsRUFBbURLLEtBQW5ELENBRGEsRUFFNUJHLElBRjRCLENBRXZCLENBQUNDLEtBQUQsRUFBUUMsS0FBUixLQUFrQkQsS0FBSyxDQUFDLENBQUQsQ0FBTCxJQUFZQyxLQUFLLENBQUMsQ0FBRCxDQUZaLEVBRzVCTixHQUg0QixDQUd2Qk8sSUFBRCxJQUFVQSxJQUFJLENBQUMsQ0FBRCxDQUhVLENBQS9COztBQUlBLFFBQU1DLFVBQVUsR0FBR3pDLGdCQUFFMEMsSUFBRixDQUFPVixzQkFBUCxDQUFuQjs7QUFDQSxRQUFNVyxTQUFTLEdBQUczQyxnQkFBRTRDLElBQUYsQ0FBT1osc0JBQVAsQ0FBbEI7O0FBQ0EsUUFBTWEsWUFBWSxHQUFHO0FBQ25CakIsSUFBQUEsQ0FBQyxFQUFFYSxVQUFVLENBQUNiLENBQVgsSUFBZ0JlLFNBQVMsQ0FBQ2YsQ0FBMUIsR0FBOEJhLFVBQVUsQ0FBQ2IsQ0FBekMsR0FBNkNlLFNBQVMsQ0FBQ2YsQ0FEdkM7QUFFbkJDLElBQUFBLENBQUMsRUFBRVksVUFBVSxDQUFDWixDQUFYLElBQWdCYyxTQUFTLENBQUNkLENBQTFCLEdBQThCWSxVQUFVLENBQUNaLENBQXpDLEdBQTZDYyxTQUFTLENBQUNkO0FBRnZDLEdBQXJCO0FBSUEsUUFBTWlCLGdCQUFnQixHQUFHO0FBQ3ZCbEIsSUFBQUEsQ0FBQyxFQUFFYSxVQUFVLENBQUNiLENBQVgsSUFBZ0JlLFNBQVMsQ0FBQ2YsQ0FBMUIsR0FBOEJhLFVBQVUsQ0FBQ2IsQ0FBekMsR0FBNkNlLFNBQVMsQ0FBQ2YsQ0FEbkM7QUFFdkJDLElBQUFBLENBQUMsRUFBRVksVUFBVSxDQUFDWixDQUFYLElBQWdCYyxTQUFTLENBQUNkLENBQTFCLEdBQThCWSxVQUFVLENBQUNaLENBQXpDLEdBQTZDYyxTQUFTLENBQUNkO0FBRm5DLEdBQXpCO0FBSUEsU0FBTztBQUNMRCxJQUFBQSxDQUFDLEVBQUVpQixZQUFZLENBQUNqQixDQURYO0FBRUxDLElBQUFBLENBQUMsRUFBRWdCLFlBQVksQ0FBQ2hCLENBRlg7QUFHTEMsSUFBQUEsS0FBSyxFQUFFZ0IsZ0JBQWdCLENBQUNsQixDQUFqQixHQUFxQmlCLFlBQVksQ0FBQ2pCLENBSHBDO0FBSUxHLElBQUFBLE1BQU0sRUFBRWUsZ0JBQWdCLENBQUNqQixDQUFqQixHQUFxQmdCLFlBQVksQ0FBQ2hCO0FBSnJDLEdBQVA7QUFNRDs7QUFVRCxTQUFTa0IsZUFBVCxDQUEwQkMsR0FBMUIsRUFBK0JDLE1BQS9CLEVBQXVDO0FBQ3JDLE1BQUlBLE1BQU0sQ0FBQ25CLEtBQVAsSUFBZ0IsQ0FBaEIsSUFBcUJtQixNQUFNLENBQUNsQixNQUFQLElBQWlCLENBQTFDLEVBQTZDO0FBQzNDO0FBQ0Q7O0FBR0QsUUFBTW1CLEtBQUssR0FBRyxJQUFJOUQsRUFBRSxDQUFDK0QsR0FBUCxDQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLEdBQWpCLENBQWQ7QUFDQSxRQUFNQyxTQUFTLEdBQUcsQ0FBbEI7QUFDQUosRUFBQUEsR0FBRyxDQUFDSyxhQUFKLENBQWtCLElBQUlqRSxFQUFFLENBQUNrRSxJQUFQLENBQVlMLE1BQU0sQ0FBQ3JCLENBQW5CLEVBQXNCcUIsTUFBTSxDQUFDcEIsQ0FBN0IsRUFBZ0NvQixNQUFNLENBQUNuQixLQUF2QyxFQUE4Q21CLE1BQU0sQ0FBQ2xCLE1BQXJELENBQWxCLEVBQWdGbUIsS0FBaEYsRUFBdUZFLFNBQXZGLEVBQWtHaEUsRUFBRSxDQUFDbUUsTUFBckc7QUFDQSxTQUFPUCxHQUFQO0FBQ0Q7O0FBZ0RELGVBQWVRLGdCQUFmLENBQWlDQyxRQUFqQyxFQUEyQ0MsUUFBM0MsRUFBcURDLE9BQU8sR0FBRyxFQUEvRCxFQUFtRTtBQUNqRSxRQUFNOUMsVUFBVSxFQUFoQjtBQUVBLFFBQU07QUFBQytDLElBQUFBLFlBQVksR0FBRyxLQUFoQjtBQUF1QkMsSUFBQUEsU0FBUyxHQUFHLEtBQW5DO0FBQ0NDLElBQUFBLGlCQUREO0FBQ29CQyxJQUFBQSxTQUFTLEdBQUc7QUFEaEMsTUFDZ0RKLE9BRHREOztBQUVBLE1BQUksQ0FBQzNELGdCQUFFZ0UsUUFBRixDQUFXdkUsbUJBQVgsRUFBZ0NtRSxZQUFoQyxDQUFMLEVBQW9EO0FBQ2xELFVBQU0sSUFBSXpELEtBQUosQ0FBVyxJQUFHeUQsWUFBYSx5QkFBakIsR0FDQyxRQUFPSyxJQUFJLENBQUNDLFNBQUwsQ0FBZXpFLG1CQUFmLENBQW9DLDJCQUR0RCxDQUFOO0FBRUQ7O0FBQ0QsTUFBSSxDQUFDTyxnQkFBRWdFLFFBQUYsQ0FBV3RFLDRCQUFYLEVBQXlDcUUsU0FBekMsQ0FBTCxFQUEwRDtBQUN4RCxVQUFNLElBQUk1RCxLQUFKLENBQVcsSUFBRzRELFNBQVUsa0NBQWQsR0FDQyxRQUFPRSxJQUFJLENBQUNDLFNBQUwsQ0FBZXhFLDRCQUFmLENBQTZDLG9DQUQvRCxDQUFOO0FBRUQ7O0FBRUQsUUFBTTBCLFFBQVEsR0FBRyxJQUFJaEMsRUFBRSxDQUFFLEdBQUV3RSxZQUFhLFVBQWpCLENBQU4sRUFBakI7QUFDQSxRQUFNLENBQUNPLElBQUQsRUFBT0MsSUFBUCxJQUFlLE1BQU12RSxrQkFBRXdFLEdBQUYsQ0FBTSxDQUMvQmpGLEVBQUUsQ0FBQ2tGLGFBQUgsQ0FBaUJiLFFBQWpCLENBRCtCLEVBRS9CckUsRUFBRSxDQUFDa0YsYUFBSCxDQUFpQlosUUFBakIsQ0FGK0IsQ0FBTixDQUEzQjtBQUlBLFFBQU0sQ0FBQ2EsT0FBRCxFQUFVQyxPQUFWLElBQXFCLE1BQU0zRSxrQkFBRXdFLEdBQUYsQ0FBTSxDQUNyQ25ELGdCQUFnQixDQUFDaUQsSUFBRCxFQUFPL0MsUUFBUCxDQURxQixFQUVyQ0YsZ0JBQWdCLENBQUNrRCxJQUFELEVBQU9oRCxRQUFQLENBRnFCLENBQU4sQ0FBakM7QUFJQSxNQUFJcUQsT0FBTyxHQUFHLEVBQWQ7O0FBQ0EsTUFBSTtBQUNGQSxJQUFBQSxPQUFPLEdBQUcsTUFBTXJGLEVBQUUsQ0FBRSxRQUFPMkUsU0FBVSxPQUFuQixDQUFGLENBQTZCUSxPQUFPLENBQUNoRCxVQUFyQyxFQUFpRGlELE9BQU8sQ0FBQ2pELFVBQXpELENBQWhCO0FBQ0QsR0FGRCxDQUVFLE9BQU9tRCxDQUFQLEVBQVU7QUFDVixVQUFNLElBQUl2RSxLQUFKLENBQVcscUZBQUQsR0FDQyxvQkFBbUJ1RSxDQUFFLEVBRGhDLENBQU47QUFFRDs7QUFDRCxRQUFNQyxVQUFVLEdBQUdGLE9BQU8sQ0FBQzlDLE1BQTNCOztBQUNBLE1BQUksb0JBQVNtQyxpQkFBVCxDQUFKLEVBQWlDO0FBQy9CLFFBQUk5RCxnQkFBRTRFLFVBQUYsQ0FBYWQsaUJBQWIsQ0FBSixFQUFxQztBQUNuQyxZQUFNZSxTQUFTLEdBQUdKLE9BQU8sQ0FBQ3hDLEdBQVIsQ0FBYTZDLEtBQUQsSUFBV0EsS0FBSyxDQUFDQyxRQUE3QixDQUFsQjs7QUFDQSxZQUFNQyxXQUFXLEdBQUdoRixnQkFBRWlGLEdBQUYsQ0FBTUosU0FBTixDQUFwQjs7QUFDQSxZQUFNSyxXQUFXLEdBQUdsRixnQkFBRW1GLEdBQUYsQ0FBTU4sU0FBTixDQUFwQjs7QUFDQUosTUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQ2RXLE1BRE8sQ0FDQ04sS0FBRCxJQUFXaEIsaUJBQWlCLENBQUNnQixLQUFLLENBQUNDLFFBQVAsRUFBaUJDLFdBQWpCLEVBQThCRSxXQUE5QixDQUQ1QixDQUFWO0FBRUQsS0FORCxNQU1PO0FBQ0wsVUFBSVQsT0FBTyxDQUFDOUMsTUFBUixHQUFpQm1DLGlCQUFyQixFQUF3QztBQUN0Q1csUUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQ2RwQyxJQURPLENBQ0YsQ0FBQ2dELE1BQUQsRUFBU0MsTUFBVCxLQUFvQkQsTUFBTSxDQUFDTixRQUFQLEdBQWtCTyxNQUFNLENBQUNQLFFBRDNDLEVBRVBRLEtBRk8sQ0FFRCxDQUZDLEVBRUV6QixpQkFGRixDQUFWO0FBR0Q7QUFDRjtBQUNGOztBQUVELFFBQU0wQixZQUFZLEdBQUcsQ0FBQ25FLFNBQUQsRUFBWW9FLGlCQUFaLEtBQW1DWCxLQUFELElBQVc7QUFDaEUsVUFBTTtBQUFDWSxNQUFBQSxFQUFEO0FBQUt4RCxNQUFBQTtBQUFMLFFBQWNiLFNBQVMsQ0FBQ3lELEtBQUssQ0FBQ1csaUJBQUQsQ0FBTixDQUE3QjtBQUVBLFdBQVFDLEVBQUUsSUFBSXhELEtBQWQ7QUFDRCxHQUpEOztBQUtBLFFBQU15RCxPQUFPLEdBQUdsQixPQUFPLENBQUN4QyxHQUFSLENBQVl1RCxZQUFZLENBQUNqQixPQUFPLENBQUNsRCxTQUFULEVBQW9CLFVBQXBCLENBQXhCLENBQWhCO0FBQ0EsUUFBTXVFLEtBQUssR0FBR25FLG9CQUFvQixDQUFDa0UsT0FBRCxDQUFsQztBQUNBLFFBQU1FLE9BQU8sR0FBR3BCLE9BQU8sQ0FBQ3hDLEdBQVIsQ0FBWXVELFlBQVksQ0FBQ2hCLE9BQU8sQ0FBQ25ELFNBQVQsRUFBb0IsVUFBcEIsQ0FBeEIsQ0FBaEI7QUFDQSxRQUFNeUUsS0FBSyxHQUFHckUsb0JBQW9CLENBQUNvRSxPQUFELENBQWxDO0FBRUEsUUFBTUUsTUFBTSxHQUFHO0FBQ2JKLElBQUFBLE9BRGE7QUFFYkMsSUFBQUEsS0FGYTtBQUdiQyxJQUFBQSxPQUhhO0FBSWJDLElBQUFBLEtBSmE7QUFLYm5CLElBQUFBLFVBTGE7QUFNYnFCLElBQUFBLEtBQUssRUFBRXZCLE9BQU8sQ0FBQzlDO0FBTkYsR0FBZjs7QUFRQSxNQUFJa0MsU0FBSixFQUFlO0FBQ2IsVUFBTW9DLGFBQWEsR0FBRzdHLEVBQUUsQ0FBQzhHLFdBQUgsQ0FBZS9CLElBQWYsRUFBcUJDLElBQXJCLEVBQTJCRyxPQUFPLENBQUNsRCxTQUFuQyxFQUE4Q21ELE9BQU8sQ0FBQ25ELFNBQXRELEVBQWlFb0QsT0FBakUsQ0FBdEI7QUFDQTFCLElBQUFBLGVBQWUsQ0FBQ2tELGFBQUQsRUFBZ0JMLEtBQWhCLENBQWY7QUFDQTdDLElBQUFBLGVBQWUsQ0FBQ2tELGFBQUQsRUFBZ0I7QUFDN0JyRSxNQUFBQSxDQUFDLEVBQUV1QyxJQUFJLENBQUNnQyxJQUFMLEdBQVlMLEtBQUssQ0FBQ2xFLENBRFE7QUFFN0JDLE1BQUFBLENBQUMsRUFBRWlFLEtBQUssQ0FBQ2pFLENBRm9CO0FBRzdCQyxNQUFBQSxLQUFLLEVBQUVnRSxLQUFLLENBQUNoRSxLQUhnQjtBQUk3QkMsTUFBQUEsTUFBTSxFQUFFK0QsS0FBSyxDQUFDL0Q7QUFKZSxLQUFoQixDQUFmO0FBTUFnRSxJQUFBQSxNQUFNLENBQUNFLGFBQVAsR0FBdUIsTUFBTTdHLEVBQUUsQ0FBQ2dILGFBQUgsQ0FBaUIsTUFBakIsRUFBeUJILGFBQXpCLENBQTdCO0FBQ0Q7O0FBQ0QsU0FBT0YsTUFBUDtBQUNEOztBQTRCRCxlQUFlTSxtQkFBZixDQUFvQzVDLFFBQXBDLEVBQThDQyxRQUE5QyxFQUF3REMsT0FBTyxHQUFHLEVBQWxFLEVBQXNFO0FBQ3BFLFFBQU05QyxVQUFVLEVBQWhCO0FBRUEsUUFBTTtBQUFDZ0QsSUFBQUEsU0FBUyxHQUFHO0FBQWIsTUFBc0JGLE9BQTVCO0FBQ0EsTUFBSSxDQUFDMkMsUUFBRCxFQUFXQyxTQUFYLElBQXdCLE1BQU0xRyxrQkFBRXdFLEdBQUYsQ0FBTSxDQUN0Q2pGLEVBQUUsQ0FBQ2tGLGFBQUgsQ0FBaUJiLFFBQWpCLENBRHNDLEVBRXRDckUsRUFBRSxDQUFDa0YsYUFBSCxDQUFpQlosUUFBakIsQ0FGc0MsQ0FBTixDQUFsQzs7QUFJQSxNQUFJNEMsUUFBUSxDQUFDRSxJQUFULEtBQWtCRCxTQUFTLENBQUNDLElBQTVCLElBQW9DRixRQUFRLENBQUNILElBQVQsS0FBa0JJLFNBQVMsQ0FBQ0osSUFBcEUsRUFBMEU7QUFDeEUsVUFBTSxJQUFJaEcsS0FBSixDQUFVLGdFQUNBLGlDQURWLENBQU47QUFFRDs7QUFDRCxHQUFDbUcsUUFBRCxFQUFXQyxTQUFYLElBQXdCLE1BQU0xRyxrQkFBRXdFLEdBQUYsQ0FBTSxDQUNsQ2lDLFFBQVEsQ0FBQ0csY0FBVCxDQUF3QnJILEVBQUUsQ0FBQ3NILE9BQTNCLENBRGtDLEVBRWxDSCxTQUFTLENBQUNFLGNBQVYsQ0FBeUJySCxFQUFFLENBQUNzSCxPQUE1QixDQUZrQyxDQUFOLENBQTlCO0FBS0EsUUFBTUMsT0FBTyxHQUFHLE1BQU1KLFNBQVMsQ0FBQ0ssa0JBQVYsQ0FBNkJOLFFBQTdCLEVBQXVDbEgsRUFBRSxDQUFDeUgsZ0JBQTFDLENBQXRCO0FBQ0EsUUFBTUMsTUFBTSxHQUFHLE1BQU1ILE9BQU8sQ0FBQ0ksY0FBUixFQUFyQjtBQUNBLFFBQU1oQixNQUFNLEdBQUc7QUFDYmlCLElBQUFBLEtBQUssRUFBRUYsTUFBTSxDQUFDRztBQURELEdBQWY7O0FBR0EsTUFBSXBELFNBQUosRUFBZTtBQUNiLFVBQU1xRCxTQUFTLEdBQUcsSUFBSTlILEVBQUUsQ0FBQytILEdBQVAsQ0FBV2IsUUFBUSxDQUFDRSxJQUFwQixFQUEwQkYsUUFBUSxDQUFDSCxJQUFULEdBQWdCLENBQTFDLEVBQTZDL0csRUFBRSxDQUFDc0gsT0FBaEQsQ0FBbEI7QUFDQSxVQUFNN0csa0JBQUV3RSxHQUFGLENBQU0sQ0FDVmtDLFNBQVMsQ0FBQ2EsV0FBVixDQUNFRixTQUFTLENBQUNHLFNBQVYsQ0FBb0IsSUFBSWpJLEVBQUUsQ0FBQ2tFLElBQVAsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQmlELFNBQVMsQ0FBQ0osSUFBNUIsRUFBa0NJLFNBQVMsQ0FBQ0MsSUFBNUMsQ0FBcEIsQ0FERixDQURVLEVBR1ZGLFFBQVEsQ0FBQ2MsV0FBVCxDQUNFRixTQUFTLENBQUNHLFNBQVYsQ0FBb0IsSUFBSWpJLEVBQUUsQ0FBQ2tFLElBQVAsQ0FBWWlELFNBQVMsQ0FBQ0osSUFBdEIsRUFBNEIsQ0FBNUIsRUFBK0JHLFFBQVEsQ0FBQ0gsSUFBeEMsRUFBOENHLFFBQVEsQ0FBQ0UsSUFBdkQsQ0FBcEIsQ0FERixDQUhVLENBQU4sQ0FBTjtBQU1BLFFBQUljLElBQUksR0FBR2YsU0FBUyxDQUFDZ0IsT0FBVixDQUFrQmpCLFFBQWxCLENBQVg7QUFDQWdCLElBQUFBLElBQUksR0FBRyxNQUFNQSxJQUFJLENBQUNFLGFBQUwsQ0FBbUJwSSxFQUFFLENBQUNxSSxjQUF0QixDQUFiO0FBQ0EsUUFBSUMsUUFBUSxHQUFHLEVBQWY7O0FBQ0EsUUFBSTtBQUNGSixNQUFBQSxJQUFJLEdBQUcsTUFBTUEsSUFBSSxDQUFDSyxjQUFMLENBQW9CLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCdkksRUFBRSxDQUFDd0ksYUFBSCxHQUFtQnhJLEVBQUUsQ0FBQ3lJLFdBQXBELENBQWI7QUFDQUgsTUFBQUEsUUFBUSxHQUFHLE1BQU1KLElBQUksQ0FBQ1EsaUJBQUwsQ0FBdUIxSSxFQUFFLENBQUMySSxhQUExQixFQUF5QzNJLEVBQUUsQ0FBQzRJLG1CQUE1QyxDQUFqQjtBQUNELEtBSEQsQ0FHRSxPQUFPQyxHQUFQLEVBQVksQ0FFYjs7QUFDRCxTQUFLLE1BQU1DLE9BQVgsSUFBc0JSLFFBQXRCLEVBQWdDO0FBQzlCLFlBQU1TLFlBQVksR0FBR0QsT0FBTyxDQUFDQyxZQUFSLEVBQXJCO0FBQ0FwRixNQUFBQSxlQUFlLENBQUNtRSxTQUFELEVBQVlpQixZQUFaLENBQWY7QUFDQXBGLE1BQUFBLGVBQWUsQ0FBQ21FLFNBQUQsRUFBWTtBQUN6QnRGLFFBQUFBLENBQUMsRUFBRTJFLFNBQVMsQ0FBQ0osSUFBVixHQUFpQmdDLFlBQVksQ0FBQ3ZHLENBRFI7QUFFekJDLFFBQUFBLENBQUMsRUFBRXNHLFlBQVksQ0FBQ3RHLENBRlM7QUFHekJDLFFBQUFBLEtBQUssRUFBRXFHLFlBQVksQ0FBQ3JHLEtBSEs7QUFJekJDLFFBQUFBLE1BQU0sRUFBRW9HLFlBQVksQ0FBQ3BHO0FBSkksT0FBWixDQUFmO0FBTUQ7O0FBQ0RnRSxJQUFBQSxNQUFNLENBQUNFLGFBQVAsR0FBdUIsTUFBTTdHLEVBQUUsQ0FBQ2dILGFBQUgsQ0FBaUIsTUFBakIsRUFBeUJjLFNBQXpCLENBQTdCO0FBQ0Q7O0FBQ0QsU0FBT25CLE1BQVA7QUFDRDs7QUFzQ0QsZUFBZXFDLGtCQUFmLENBQW1DQyxXQUFuQyxFQUFnREMsY0FBaEQsRUFBZ0UzRSxPQUFPLEdBQUcsRUFBMUUsRUFBOEU7QUFDNUUsUUFBTTlDLFVBQVUsRUFBaEI7QUFFQSxRQUFNO0FBQUVnRCxJQUFBQSxTQUFTLEdBQUcsS0FBZDtBQUNFMEUsSUFBQUEsU0FBUyxHQUFHaEosdUJBRGQ7QUFFRWlKLElBQUFBLFFBQVEsR0FBRyxLQUZiO0FBR0VDLElBQUFBLHVCQUF1QixHQUFHako7QUFINUIsTUFHMERtRSxPQUhoRTtBQUtBLFFBQU0sQ0FBQytFLE9BQUQsRUFBVUMsVUFBVixJQUF3QixNQUFNOUksa0JBQUV3RSxHQUFGLENBQU0sQ0FDeENqRixFQUFFLENBQUNrRixhQUFILENBQWlCK0QsV0FBakIsQ0FEd0MsRUFFeENqSixFQUFFLENBQUNrRixhQUFILENBQWlCZ0UsY0FBakIsQ0FGd0MsQ0FBTixDQUFwQztBQUlBLFFBQU1NLE9BQU8sR0FBRyxFQUFoQjtBQUNBLE1BQUkzQyxhQUFhLEdBQUcsSUFBcEI7O0FBRUEsTUFBSTtBQUNGLFVBQU1VLE9BQU8sR0FBRyxNQUFNK0IsT0FBTyxDQUFDOUIsa0JBQVIsQ0FBMkIrQixVQUEzQixFQUF1Q3ZKLEVBQUUsQ0FBQ3lILGdCQUExQyxDQUF0QjtBQUNBLFVBQU1DLE1BQU0sR0FBRyxNQUFNSCxPQUFPLENBQUNJLGNBQVIsRUFBckI7O0FBRUEsUUFBSXlCLFFBQUosRUFBYztBQUNaLFlBQU1LLG1CQUFtQixHQUFHbEMsT0FBTyxDQUFDNEIsU0FBUixDQUFrQkEsU0FBbEIsRUFBNkIsQ0FBN0IsRUFBZ0NuSixFQUFFLENBQUN3SSxhQUFuQyxFQUFrRGtCLFNBQWxELENBQTREMUosRUFBRSxDQUFDMkosS0FBL0QsRUFBc0VDLFdBQXRFLEVBQTVCO0FBQ0EsWUFBTXZFLE9BQU8sR0FBR3dFLGlCQUFpQixDQUFDSixtQkFBRCxFQUFzQkosdUJBQXRCLENBQWpDOztBQUVBLFdBQUssTUFBTVMsT0FBWCxJQUFzQnpFLE9BQXRCLEVBQStCO0FBQzdCbUUsUUFBQUEsT0FBTyxDQUFDTyxJQUFSLENBQWE7QUFDWG5DLFVBQUFBLEtBQUssRUFBRUwsT0FBTyxDQUFDeUMsRUFBUixDQUFXRixPQUFPLENBQUNySCxDQUFuQixFQUFzQnFILE9BQU8sQ0FBQ3RILENBQTlCLENBREk7QUFFWHlILFVBQUFBLElBQUksRUFBRTtBQUNKekgsWUFBQUEsQ0FBQyxFQUFFc0gsT0FBTyxDQUFDdEgsQ0FEUDtBQUVKQyxZQUFBQSxDQUFDLEVBQUVxSCxPQUFPLENBQUNySCxDQUZQO0FBR0pDLFlBQUFBLEtBQUssRUFBRTZHLFVBQVUsQ0FBQ3hDLElBSGQ7QUFJSnBFLFlBQUFBLE1BQU0sRUFBRTRHLFVBQVUsQ0FBQ25DO0FBSmY7QUFGSyxTQUFiO0FBU0Q7QUFDRixLQWZELE1BZU8sSUFBSU0sTUFBTSxDQUFDRyxNQUFQLElBQWlCc0IsU0FBckIsRUFBZ0M7QUFDckNLLE1BQUFBLE9BQU8sQ0FBQ08sSUFBUixDQUFhO0FBQ1huQyxRQUFBQSxLQUFLLEVBQUVGLE1BQU0sQ0FBQ0csTUFESDtBQUVYb0MsUUFBQUEsSUFBSSxFQUFFO0FBQ0p6SCxVQUFBQSxDQUFDLEVBQUVrRixNQUFNLENBQUN3QyxNQUFQLENBQWMxSCxDQURiO0FBRUpDLFVBQUFBLENBQUMsRUFBRWlGLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBY3pILENBRmI7QUFHSkMsVUFBQUEsS0FBSyxFQUFFNkcsVUFBVSxDQUFDeEMsSUFIZDtBQUlKcEUsVUFBQUEsTUFBTSxFQUFFNEcsVUFBVSxDQUFDbkM7QUFKZjtBQUZLLE9BQWI7QUFTRDs7QUFFRCxRQUFJeEcsZ0JBQUV1SixPQUFGLENBQVVYLE9BQVYsQ0FBSixFQUF3QjtBQUV0QixZQUFNLElBQUl6SSxLQUFKLENBQVcsb0JBQW1Cb0ksU0FBVSx3QkFBOUIsR0FDQyxhQUFZekIsTUFBTSxDQUFDRyxNQUFPLEVBRHJDLENBQU47QUFFRDtBQUNGLEdBcENELENBb0NFLE9BQU92QyxDQUFQLEVBQVU7QUFFVixVQUFNLElBQUl2RSxLQUFKLENBQVcsc0VBQUQsR0FDYixtQkFBa0J1RSxDQUFDLENBQUN6RCxPQUFRLEVBRHpCLENBQU47QUFFRDs7QUFFRCxNQUFJNEMsU0FBSixFQUFlO0FBQ2IsVUFBTTJGLG9CQUFvQixHQUFHZCxPQUFPLENBQUNlLElBQVIsRUFBN0I7O0FBRUEsU0FBSyxNQUFNMUQsTUFBWCxJQUFxQjZDLE9BQXJCLEVBQThCO0FBQzVCLFlBQU1jLHNCQUFzQixHQUFHaEIsT0FBTyxDQUFDZSxJQUFSLEVBQS9CO0FBRUExRyxNQUFBQSxlQUFlLENBQUMyRyxzQkFBRCxFQUF5QjNELE1BQU0sQ0FBQ3NELElBQWhDLENBQWY7QUFDQXRHLE1BQUFBLGVBQWUsQ0FBQ3lHLG9CQUFELEVBQXVCekQsTUFBTSxDQUFDc0QsSUFBOUIsQ0FBZjtBQUNBdEQsTUFBQUEsTUFBTSxDQUFDRSxhQUFQLEdBQXVCLE1BQU03RyxFQUFFLENBQUNnSCxhQUFILENBQWlCLE1BQWpCLEVBQXlCc0Qsc0JBQXpCLENBQTdCO0FBQ0Q7O0FBQ0R6RCxJQUFBQSxhQUFhLEdBQUcsTUFBTTdHLEVBQUUsQ0FBQ2dILGFBQUgsQ0FBaUIsTUFBakIsRUFBeUJvRCxvQkFBekIsQ0FBdEI7QUFDRDs7QUFFRCxTQUFPO0FBQ0xILElBQUFBLElBQUksRUFBRVQsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXUyxJQURaO0FBRUxyQyxJQUFBQSxLQUFLLEVBQUU0QixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVc1QixLQUZiO0FBR0xmLElBQUFBLGFBSEs7QUFJTHVDLElBQUFBLFFBQVEsRUFBRUk7QUFKTCxHQUFQO0FBTUQ7O0FBVUQsU0FBU0ssaUJBQVQsQ0FBNEJKLG1CQUE1QixFQUFpREosdUJBQWpELEVBQTBFO0FBQ3hFLFNBQU9JLG1CQUFtQixDQUFDYyxNQUFwQixDQUEyQixDQUFDQyxHQUFELEVBQU1WLE9BQU4sS0FBa0I7QUFDbEQsUUFBSSxDQUFDVSxHQUFHLENBQUNDLElBQUosQ0FBVS9FLEtBQUQsSUFBV0MsUUFBUSxDQUFDRCxLQUFELEVBQVFvRSxPQUFSLENBQVIsSUFBNEJULHVCQUFoRCxDQUFMLEVBQStFO0FBQzdFbUIsTUFBQUEsR0FBRyxDQUFDVCxJQUFKLENBQVNELE9BQVQ7QUFDRDs7QUFDRCxXQUFPVSxHQUFQO0FBQ0QsR0FMTSxFQUtKLEVBTEksQ0FBUDtBQU1EOztBQVNELFNBQVM3RSxRQUFULENBQW1CK0UsTUFBbkIsRUFBMkJDLE1BQTNCLEVBQW1DO0FBQ2pDLFFBQU1DLEVBQUUsR0FBRzdILElBQUksQ0FBQzhILEdBQUwsQ0FBVUgsTUFBTSxDQUFDbEksQ0FBUCxHQUFXbUksTUFBTSxDQUFDbkksQ0FBNUIsRUFBZ0MsQ0FBaEMsQ0FBWDtBQUNBLFFBQU1zSSxFQUFFLEdBQUcvSCxJQUFJLENBQUM4SCxHQUFMLENBQVVILE1BQU0sQ0FBQ2pJLENBQVAsR0FBV2tJLE1BQU0sQ0FBQ2xJLENBQTVCLEVBQWdDLENBQWhDLENBQVg7QUFDQSxTQUFPTSxJQUFJLENBQUNDLElBQUwsQ0FBVTRILEVBQUUsR0FBR0UsRUFBZixDQUFQO0FBQ0Q7O0FBU0QsZUFBZUMsZUFBZixDQUFnQ0MsV0FBaEMsRUFBNkNmLElBQTdDLEVBQW1EO0FBQ2pELFFBQU1nQixLQUFLLEdBQUcsTUFBTUMsYUFBYSxDQUFDRixXQUFELENBQWpDO0FBQ0FHLEVBQUFBLFNBQVMsQ0FBQ0YsS0FBRCxFQUFRaEIsSUFBUixDQUFUO0FBQ0EsU0FBTyxNQUFNbUIsYUFBYSxDQUFDSCxLQUFELENBQTFCO0FBQ0Q7O0FBUUQsZUFBZUMsYUFBZixDQUE4QkYsV0FBOUIsRUFBMkM7QUFDekMsUUFBTUssV0FBVyxHQUFHckssZUFBT0MsSUFBUCxDQUFZK0osV0FBWixFQUF5QixRQUF6QixDQUFwQjs7QUFDQSxTQUFPLE1BQU0sSUFBSXZLLGlCQUFKLENBQU0sQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDLFVBQU1zSyxLQUFLLEdBQUcsSUFBSUssVUFBSixDQUFRO0FBQUNDLE1BQUFBLFVBQVUsRUFBRXJMO0FBQWIsS0FBUixDQUFkO0FBQ0ErSyxJQUFBQSxLQUFLLENBQUNPLEtBQU4sQ0FBWUgsV0FBWixFQUF5QixDQUFDbkssR0FBRCxFQUFNK0osS0FBTixLQUFnQjtBQUN2QyxVQUFJL0osR0FBSixFQUFTO0FBQ1AsZUFBT1AsTUFBTSxDQUFDTyxHQUFELENBQWI7QUFDRDs7QUFDRFIsTUFBQUEsT0FBTyxDQUFDdUssS0FBRCxDQUFQO0FBQ0QsS0FMRDtBQU1ELEdBUlksQ0FBYjtBQVNEOztBQVFELGVBQWVHLGFBQWYsQ0FBOEJILEtBQTlCLEVBQXFDO0FBQ25DLFNBQU8sTUFBTSxJQUFJeEssaUJBQUosQ0FBTSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdEMsVUFBTThLLE1BQU0sR0FBRyxFQUFmO0FBQ0FSLElBQUFBLEtBQUssQ0FBQ1MsSUFBTixHQUNDQyxFQURELENBQ0ksTUFESixFQUNhQyxLQUFELElBQVdILE1BQU0sQ0FBQzFCLElBQVAsQ0FBWTZCLEtBQVosQ0FEdkIsRUFDMkNELEVBRDNDLENBQzhDLEtBRDlDLEVBQ3FELE1BQU07QUFDekRqTCxNQUFBQSxPQUFPLENBQUNNLGVBQU82SyxNQUFQLENBQWNKLE1BQWQsRUFBc0JLLFFBQXRCLENBQStCLFFBQS9CLENBQUQsQ0FBUDtBQUNELEtBSEQsRUFJQ0gsRUFKRCxDQUlJLE9BSkosRUFJY3pLLEdBQUQsSUFBUztBQUNwQlAsTUFBQUEsTUFBTSxDQUFDTyxHQUFELENBQU47QUFDRCxLQU5EO0FBT0QsR0FUWSxDQUFiO0FBVUQ7O0FBUUQsU0FBU2lLLFNBQVQsQ0FBb0JGLEtBQXBCLEVBQTJCaEIsSUFBM0IsRUFBaUM7QUFDL0IsUUFBTThCLFNBQVMsR0FBRztBQUFDckosSUFBQUEsS0FBSyxFQUFFdUksS0FBSyxDQUFDdkksS0FBZDtBQUFxQkMsSUFBQUEsTUFBTSxFQUFFc0ksS0FBSyxDQUFDdEk7QUFBbkMsR0FBbEI7QUFDQSxRQUFNcUosU0FBUyxHQUFHQyxtQkFBbUIsQ0FBQ2hDLElBQUQsRUFBTzhCLFNBQVAsQ0FBckM7O0FBQ0EsTUFBSUMsU0FBUyxDQUFDdEosS0FBVixHQUFrQnVILElBQUksQ0FBQ3ZILEtBQXZCLElBQWdDc0osU0FBUyxDQUFDckosTUFBVixHQUFtQnNILElBQUksQ0FBQ3RILE1BQTVELEVBQW9FO0FBQ2xFLFVBQU0sSUFBSTVCLEtBQUosQ0FBVyxlQUFjOEQsSUFBSSxDQUFDQyxTQUFMLENBQWVtRixJQUFmLENBQXFCLFNBQVFwRixJQUFJLENBQUNDLFNBQUwsQ0FBZWlILFNBQWYsQ0FBMEIscUVBQWhGLENBQU47QUFDRDs7QUFFRCxRQUFNRyxrQkFBa0IsR0FBR0YsU0FBUyxDQUFDRyxHQUFyQztBQUNBLFFBQU1DLGlCQUFpQixHQUFHSixTQUFTLENBQUNHLEdBQVYsR0FBZ0JILFNBQVMsQ0FBQ3JKLE1BQXBEO0FBRUEsUUFBTTBKLG9CQUFvQixHQUFHTCxTQUFTLENBQUNNLElBQXZDO0FBQ0EsUUFBTUMsbUJBQW1CLEdBQUdQLFNBQVMsQ0FBQ00sSUFBVixHQUFpQk4sU0FBUyxDQUFDdEosS0FBdkQ7QUFFQSxRQUFNOEosWUFBWSxHQUFHLEVBQXJCOztBQUNBLE9BQUssSUFBSS9KLENBQUMsR0FBR3lKLGtCQUFiLEVBQWlDekosQ0FBQyxHQUFHMkosaUJBQXJDLEVBQXdEM0osQ0FBQyxFQUF6RCxFQUE2RDtBQUMzRCxTQUFLLElBQUlELENBQUMsR0FBRzZKLG9CQUFiLEVBQW1DN0osQ0FBQyxHQUFHK0osbUJBQXZDLEVBQTREL0osQ0FBQyxFQUE3RCxFQUFpRTtBQUMvRCxZQUFNaUssd0JBQXdCLEdBQUlWLFNBQVMsQ0FBQ3JKLEtBQVYsR0FBa0JELENBQWxCLEdBQXNCRCxDQUF2QixJQUE2QixDQUE5RDs7QUFDQSxXQUFLLElBQUlrSyxPQUFPLEdBQUcsQ0FBbkIsRUFBc0JBLE9BQU8sR0FBR3pNLG9CQUFoQyxFQUFzRHlNLE9BQU8sRUFBN0QsRUFBaUU7QUFDL0RGLFFBQUFBLFlBQVksQ0FBQ3pDLElBQWIsQ0FBa0JrQixLQUFLLENBQUN6SyxJQUFOLENBQVdpTSx3QkFBd0IsR0FBR0MsT0FBdEMsQ0FBbEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUR6QixFQUFBQSxLQUFLLENBQUN6SyxJQUFOLEdBQWFRLGVBQU9DLElBQVAsQ0FBWXVMLFlBQVosQ0FBYjtBQUNBdkIsRUFBQUEsS0FBSyxDQUFDdkksS0FBTixHQUFjc0osU0FBUyxDQUFDdEosS0FBeEI7QUFDQXVJLEVBQUFBLEtBQUssQ0FBQ3RJLE1BQU4sR0FBZXFKLFNBQVMsQ0FBQ3JKLE1BQXpCO0FBQ0EsU0FBT3NJLEtBQVA7QUFDRDs7QUFFRCxTQUFTZ0IsbUJBQVQsQ0FBOEJoQyxJQUE5QixFQUFvQzBDLFNBQXBDLEVBQStDO0FBQzdDLFFBQU1MLElBQUksR0FBR3JDLElBQUksQ0FBQ3FDLElBQUwsSUFBYUssU0FBUyxDQUFDakssS0FBdkIsR0FBK0JpSyxTQUFTLENBQUNqSyxLQUF6QyxHQUFpRHVILElBQUksQ0FBQ3FDLElBQW5FO0FBQ0EsUUFBTUgsR0FBRyxHQUFHbEMsSUFBSSxDQUFDa0MsR0FBTCxJQUFZUSxTQUFTLENBQUNoSyxNQUF0QixHQUErQmdLLFNBQVMsQ0FBQ2hLLE1BQXpDLEdBQWtEc0gsSUFBSSxDQUFDa0MsR0FBbkU7QUFDQSxRQUFNekosS0FBSyxHQUFHaUssU0FBUyxDQUFDakssS0FBVixJQUFvQjRKLElBQUksR0FBR3JDLElBQUksQ0FBQ3ZILEtBQWhDLEdBQXlDdUgsSUFBSSxDQUFDdkgsS0FBOUMsR0FBdURpSyxTQUFTLENBQUNqSyxLQUFWLEdBQWtCNEosSUFBdkY7QUFDQSxRQUFNM0osTUFBTSxHQUFHZ0ssU0FBUyxDQUFDaEssTUFBVixJQUFxQndKLEdBQUcsR0FBR2xDLElBQUksQ0FBQ3RILE1BQWhDLEdBQTBDc0gsSUFBSSxDQUFDdEgsTUFBL0MsR0FBeURnSyxTQUFTLENBQUNoSyxNQUFWLEdBQW1Cd0osR0FBM0Y7QUFDQSxTQUFPO0FBQUNHLElBQUFBLElBQUQ7QUFBT0gsSUFBQUEsR0FBUDtBQUFZekosSUFBQUEsS0FBWjtBQUFtQkMsSUFBQUE7QUFBbkIsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBKaW1wIGZyb20gJ2ppbXAnO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IFBORyB9IGZyb20gJ3BuZ2pzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IGhhc1ZhbHVlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgcmVxdWlyZVBhY2thZ2UgfSBmcm9tICcuL25vZGUnO1xuXG5cbmNvbnN0IHsgTUlNRV9KUEVHLCBNSU1FX1BORywgTUlNRV9CTVAgfSA9IEppbXA7XG5sZXQgY3YgPSBudWxsO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZ2lvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgLSBUaGUgb2Zmc2V0IGZyb20gdGhlIGxlZnQgc2lkZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCAtIFRoZSBvZmZzZXQgZnJvbSB0aGUgdG9wXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0geSAtIFRoZSB5IGNvb3JkaW5hdGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlY3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0gVGhlIHRvcCBsZWZ0IGNvb3JkaW5hdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0gVGhlIGJvdHRvbSByaWdodCBjb29yZGluYXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0XG4gKi9cblxuY29uc3QgQllURVNfSU5fUElYRUxfQkxPQ0sgPSA0O1xuY29uc3QgU0NBTkxJTkVfRklMVEVSX01FVEhPRCA9IDQ7XG5jb25zdCBERUZBVUxUX01BVENIX1RIUkVTSE9MRCA9IDAuNTtcbmNvbnN0IE1BVENIX05FSUdIQk9VUl9USFJFU0hPTEQgPSAxMDtcblxuY29uc3QgQVZBSUxBQkxFX0RFVEVDVE9SUyA9IFtcbiAgJ0FLQVpFJyxcbiAgJ0FHQVNUJyxcbiAgJ0JSSVNLJyxcbiAgJ0ZBU1QnLFxuICAnR0ZUVCcsXG4gICdLQVpFJyxcbiAgJ01TRVInLFxuICAnU0lGVCcsXG4gICdPUkInLFxuXTtcblxuY29uc3QgQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OUyA9IFtcbiAgJ0ZsYW5uQmFzZWQnLFxuICAnQnJ1dGVGb3JjZScsXG4gICdCcnV0ZUZvcmNlTDEnLFxuICAnQnJ1dGVGb3JjZUhhbW1pbmcnLFxuICAnQnJ1dGVGb3JjZUhhbW1pbmdMdXQnLFxuICAnQnJ1dGVGb3JjZVNMMicsXG5dO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZ2V0IGEgSmltcCBpbWFnZSBvYmplY3QgZnJvbSBidWZmZXIgb3IgYmFzZTY0IGRhdGEuIEppbXBcbiAqIGlzIGEgZ3JlYXQgbGlicmFyeSBob3dldmVyIGl0IGRvZXMgSU8gaW4gdGhlIGNvbnN0cnVjdG9yIHNvIGl0J3Mgbm90XG4gKiBjb252ZW5pZW50IGZvciBvdXIgYXN5bmMvYXdhaXQgbW9kZWwuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBkYXRhIC0gYmluYXJ5IGltYWdlIGJ1ZmZlciBvciBiYXNlNjQtZW5jb2RlZCBpbWFnZVxuICogc3RyaW5nXG4gKiBAcmV0dXJucyB7SmltcH0gLSB0aGUgamltcCBpbWFnZSBvYmplY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SmltcEltYWdlIChkYXRhKSB7XG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGRhdGEpICYmICFfLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTXVzdCBpbml0aWFsaXplIGppbXAgb2JqZWN0IHdpdGggc3RyaW5nIG9yIGJ1ZmZlcicpKTtcbiAgICB9XG4gICAgLy8gaWYgZGF0YSBpcyBhIHN0cmluZywgYXNzdW1lIGl0IGlzIGEgYmFzZTY0LWVuY29kZWQgaW1hZ2VcbiAgICBpZiAoXy5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcbiAgICB9XG4gICAgbmV3IEppbXAoZGF0YSwgKGVyciwgaW1nT2JqKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaW1nT2JqKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGppbXAgaW1hZ2UgZnJvbSB0aGF0IGRhdGEnKSk7XG4gICAgICB9XG4gICAgICBpbWdPYmouX2dldEJ1ZmZlciA9IGltZ09iai5nZXRCdWZmZXIuYmluZChpbWdPYmopO1xuICAgICAgaW1nT2JqLmdldEJ1ZmZlciA9IEIucHJvbWlzaWZ5KGltZ09iai5fZ2V0QnVmZmVyLCB7Y29udGV4dDogaW1nT2JqfSk7XG4gICAgICByZXNvbHZlKGltZ09iaik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuY3Y0bm9kZWpzIG1vZHVsZSBpcyBub3QgaW5zdGFsbGVkIG9yIGNhbm5vdCBiZSBsb2FkZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdE9wZW5DViAoKSB7XG4gIGlmIChjdikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgSW5pdGlhbGl6aW5nIG9wZW5jdmApO1xuICB0cnkge1xuICAgIGN2ID0gYXdhaXQgcmVxdWlyZVBhY2thZ2UoJ29wZW5jdjRub2RlanMnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYFVuYWJsZSB0byBsb2FkICdvcGVuY3Y0bm9kZWpzJzogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuXG4gIGlmICghY3YpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCdvcGVuY3Y0bm9kZWpzJyBtb2R1bGUgaXMgcmVxdWlyZWQgdG8gdXNlIE9wZW5DViBmZWF0dXJlcy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBQbGVhc2UgaW5zdGFsbCBpdCBmaXJzdCAoJ25wbSBpIC1nIG9wZW5jdjRub2RlanMnKSBhbmQgcmVzdGFydCBBcHBpdW0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAnUmVhZCBodHRwczovL2dpdGh1Yi5jb20vanVzdGFkdWRld2hvaGFja3Mvb3BlbmN2NG5vZGVqcyNob3ctdG8taW5zdGFsbCBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgdG9waWMuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXRjaENvbXB1dGF0aW9uUmVzdWx0XG4gKiBAcHJvcGVydHkge2N2LkRlc2NyaXB0b3JNYXRjaH0gZGVzY2lwdG9yIC0gT3BlbkNWIG1hdGNoIGRlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8Y3YuS2V5UG9pbnQ+fSBrZXlQb2ludHMgLSBUaGUgYXJyYXkgb2Yga2V5IHBvaW50c1xuICovXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhbiBPcGVuQ1YgbWF0Y2ggZGVzY3JpcHRvciBvZiBhbiBpbWFnZSwgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIGZvciBicnV0ZS1mb3JjZSBtYXRjaGluZy5cbiAqIFJlYWQgaHR0cHM6Ly9kb2NzLm9wZW5jdi5vcmcvMy4wLWJldGEvZG9jL3B5X3R1dG9yaWFscy9weV9mZWF0dXJlMmQvcHlfbWF0Y2hlci9weV9tYXRjaGVyLmh0bWxcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHtjdi5NYXR9IGltZyBJbWFnZSBkYXRhXG4gKiBAcGFyYW0ge2N2LkZlYXR1cmVEZXRlY3Rvcn0gZGV0ZWN0b3IgT3BlbkNWIGZlYXR1cmUgZGV0ZWN0b3IgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJucyB7TWF0Y2hDb21wdXRhdGlvblJlc3VsdH1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0QW5kQ29tcHV0ZSAoaW1nLCBkZXRlY3Rvcikge1xuICBjb25zdCBrZXlQb2ludHMgPSBhd2FpdCBkZXRlY3Rvci5kZXRlY3RBc3luYyhpbWcpO1xuICBjb25zdCBkZXNjcmlwdG9yID0gYXdhaXQgZGV0ZWN0b3IuY29tcHV0ZUFzeW5jKGltZywga2V5UG9pbnRzKTtcbiAgcmV0dXJuIHtcbiAgICBrZXlQb2ludHMsXG4gICAgZGVzY3JpcHRvclxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZWQgdGhlIGJvdW5kaW5nIHJlY3QgY29vcmRpbmF0ZXMgZm9yIHRoZSBhcnJheSBvZiBtYXRjaGluZyBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBvaW50Pn0gbWF0Y2hlZFBvaW50cyBBcnJheSBvZiBtYXRjaGluZyBwb2ludHNcbiAqIEByZXR1cm5zIHtSZWN0fSBUaGUgbWF0Y2hpbmcgYm91bmRpbmcgcmVjdCBvciBhIHplcm8gcmVjdCBpZiBubyBtYXRjaFxuICogY2FuIGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVNYXRjaGVkUmVjdCAobWF0Y2hlZFBvaW50cykge1xuICBpZiAobWF0Y2hlZFBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgcG9pbnRzU29ydGVkQnlEaXN0YW5jZSA9IG1hdGNoZWRQb2ludHNcbiAgICAubWFwKChwb2ludCkgPT4gW01hdGguc3FydChwb2ludC54ICogcG9pbnQueCArIHBvaW50LnkgKiBwb2ludC55KSwgcG9pbnRdKVxuICAgIC5zb3J0KChwYWlyMSwgcGFpcjIpID0+IHBhaXIxWzBdID49IHBhaXIyWzBdKVxuICAgIC5tYXAoKHBhaXIpID0+IHBhaXJbMV0pO1xuICBjb25zdCBmaXJzdFBvaW50ID0gXy5oZWFkKHBvaW50c1NvcnRlZEJ5RGlzdGFuY2UpO1xuICBjb25zdCBsYXN0UG9pbnQgPSBfLmxhc3QocG9pbnRzU29ydGVkQnlEaXN0YW5jZSk7XG4gIGNvbnN0IHRvcExlZnRQb2ludCA9IHtcbiAgICB4OiBmaXJzdFBvaW50LnggPD0gbGFzdFBvaW50LnggPyBmaXJzdFBvaW50LnggOiBsYXN0UG9pbnQueCxcbiAgICB5OiBmaXJzdFBvaW50LnkgPD0gbGFzdFBvaW50LnkgPyBmaXJzdFBvaW50LnkgOiBsYXN0UG9pbnQueSxcbiAgfTtcbiAgY29uc3QgYm90dG9tUmlnaHRQb2ludCA9IHtcbiAgICB4OiBmaXJzdFBvaW50LnggPj0gbGFzdFBvaW50LnggPyBmaXJzdFBvaW50LnggOiBsYXN0UG9pbnQueCxcbiAgICB5OiBmaXJzdFBvaW50LnkgPj0gbGFzdFBvaW50LnkgPyBmaXJzdFBvaW50LnkgOiBsYXN0UG9pbnQueSxcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB4OiB0b3BMZWZ0UG9pbnQueCxcbiAgICB5OiB0b3BMZWZ0UG9pbnQueSxcbiAgICB3aWR0aDogYm90dG9tUmlnaHRQb2ludC54IC0gdG9wTGVmdFBvaW50LngsXG4gICAgaGVpZ2h0OiBib3R0b21SaWdodFBvaW50LnkgLSB0b3BMZWZ0UG9pbnQueVxuICB9O1xufVxuXG4vKipcbiAqIERyYXdzIGEgcmVjdGFubmdsZSBvbiB0aGUgZ2l2ZW4gaW1hZ2UgbWF0cml4XG4gKlxuICogQHBhcmFtIHtjdi5NYXR9IG1hdCBUaGUgc291cmNlIGltYWdlXG4gKiBAcGFyYW0ge1JlY3R9IHJlZ2lvbiBUaGUgcmVnaW9uIHRvIGhpZ2hsaWdodFxuICpcbiAqIEByZXR1cm5zIHtjdi5NYXR9IFRoZSBzYW1lIGltYWdlIHdpdGggdGhlIHJlY3RhbmdlIG9uIGl0XG4gKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFJlZ2lvbiAobWF0LCByZWdpb24pIHtcbiAgaWYgKHJlZ2lvbi53aWR0aCA8PSAwIHx8IHJlZ2lvbi5oZWlnaHQgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGhpZ2hsaWdodCBpbiByZWRcbiAgY29uc3QgY29sb3IgPSBuZXcgY3YuVmVjKDAsIDAsIDI1NSk7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IDI7XG4gIG1hdC5kcmF3UmVjdGFuZ2xlKG5ldyBjdi5SZWN0KHJlZ2lvbi54LCByZWdpb24ueSwgcmVnaW9uLndpZHRoLCByZWdpb24uaGVpZ2h0KSwgY29sb3IsIHRoaWNrbmVzcywgY3YuTElORV84KTtcbiAgcmV0dXJuIG1hdDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXRjaGluZ09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZGV0ZWN0b3JOYW1lIFsnT1JCJ10gT25lIG9mIHBvc3NpYmxlIE9wZW5DViBmZWF0dXJlIGRldGVjdG9yIG5hbWVzXG4gKiBmcm9tIGBBVkFJTEFCTEVfREVURUNUT1JTYCBhcnJheS5cbiAqIFNvbWUgb2YgdGhlc2UgbWV0aG9kcyAoRkFTVCwgQUdBU1QsIEdGVFQsIEZBU1QsIFNJRlQgYW5kIE1TRVIpIGFyZSBub3QgYXZhaWxhYmxlXG4gKiBpbiB0aGUgZGVmYXVsdCBPcGVuQ1YgaW5zdGFsbGF0aW9uIGFuZCBoYXZlIHRvIGJlIGVuYWJsZWQgbWFudWFsbHkgYmVmb3JlXG4gKiBsaWJyYXJ5IGNvbXBpbGF0aW9uLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBtYXRjaEZ1bmMgWydCcnV0ZUZvcmNlJ10gVGhlIG5hbWUgb2YgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uLlxuICogU2hvdWxkIGJlIG9uZSBvZiBgQVZBSUxBQkxFX01BVENISU5HX0ZVTkNUSU9OU2AgYXJyYXkuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ8RnVuY3Rpb259IGdvb2RNYXRjaGVzRmFjdG9yIFRoZSBtYXhpbXVtIGNvdW50IG9mIFwiZ29vZFwiIG1hdGNoZXNcbiAqIChlLiBnLiB3aXRoIG1pbmltYWwgZGlzdGFuY2VzKSBvciBhIGZ1bmN0aW9uLCB3aGljaCBhY2NlcHRzIDMgYXJndW1lbnRzOiB0aGUgY3VycmVudCBkaXN0YW5jZSxcbiAqIG1pbmltYWwgZGlzdGFuY2UsIG1heGltdW0gZGlzdGFuY2UgYW5kIHJldHVybnMgdHJ1ZSBvciBmYWxzZSB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgdGhlIG1hdGNoLlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gdmlzdWFsaXplIFtmYWxzZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdGluZyB2aXNhbGl6YXRpb25cbiAqIGFzIGFuIGltYWdlICh1c2VmdWwgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hdGNoaW5nUmVzdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gY291bnQgVGhlIGNvdW50IG9mIG1hdGNoZWQgZWRnZXMgb24gYm90aCBpbWFnZXMuXG4gKiBUaGUgbW9yZSBtYXRjaGluZyBlZGdlcyB0aGVyZSBhcmUgbm8gYm90aCBpbWFnZXMgdGhlIG1vcmUgc2ltaWxhciB0aGV5IGFyZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3RhbENvdW50IFRoZSB0b3RhbCBjb3VudCBvZiBtYXRjaGVkIGVkZ2VzIG9uIGJvdGggaW1hZ2VzLlxuICogSXQgaXMgZXF1YWwgdG8gYGNvdW50YCBpZiBgZ29vZE1hdGNoZXNGYWN0b3JgIGRvZXMgbm90IGxpbWl0IHRoZSBtYXRjaGVzLFxuICogb3RoZXJ3aXNlIGl0IGNvbnRhaW5zIHRoZSB0b3RhbCBjb3VudCBvZiBtYXRjaGVzIGJlZm9yZSBgZ29vZE1hdGNoZXNGYWN0b3JgIGlzXG4gKiBhcHBsaWVkLlxuICogQHByb3BlcnR5IHs/QnVmZmVyfSB2aXN1YWxpemF0aW9uIFRoZSB2aXN1YWxpemF0aW9uIG9mIHRoZSBtYXRjaGluZyByZXN1bHRcbiAqIHJlcHJlc2VudGVkIGFzIFBORyBpbWFnZSBidWZmZXIuIFRoaXMgdmlzdWFsaXphdGlvbiBsb29rcyBsaWtlXG4gKiBodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8zMTEyNTUyMS8yOTcwMjczMS1jNzllMzE0Mi04OTcyLTExZTctOTQ3ZS1kYjEwOWQ0MTU0NjkuanBnXG4gKiBAcHJvcGVydHkge0FycmF5PFBvaW50Pn0gcG9pbnRzMSBUaGUgYXJyYXkgb2YgbWF0Y2hpbmcgcG9pbnRzIG9uIHRoZSBmaXJzdCBpbWFnZVxuICogQHByb3BlcnR5IHtSZWN0fSByZWN0MSBUaGUgYm91bmRpbmcgcmVjdCBmb3IgdGhlIGBtYXRjaGVkUG9pbnRzMWAgc2V0IG9yIGEgemVybyByZWN0XG4gKiBpZiBub3QgZW5vdWdoIG1hdGNoaW5nIHBvaW50cyBhcmUgZm91bmRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UG9pbnQ+fSBwb2ludHMyIFRoZSBhcnJheSBvZiBtYXRjaGluZyBwb2ludHMgb24gdGhlIHNlY29uZCBpbWFnZVxuICogQHByb3BlcnR5IHtSZWN0fSByZWN0MiBUaGUgYm91bmRpbmcgcmVjdCBmb3IgdGhlIGBtYXRjaGVkUG9pbnRzMmAgc2V0IG9yIGEgemVybyByZWN0XG4gKiBpZiBub3QgZW5vdWdoIG1hdGNoaW5nIHBvaW50cyBhcmUgZm91bmRcbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvdW50IG9mIGNvbW1vbiBlZGdlcyBiZXR3ZWVuIHR3byBpbWFnZXMuXG4gKiBUaGUgaW1hZ2VzIG1pZ2h0IGJlIHJvdGF0ZWQgb3IgcmVzaXplZCByZWxhdGl2ZWx5IHRvIGVhY2ggb3RoZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGltZzFEYXRhIFRoZSBkYXRhIG9mIHRoZSBmaXJzdCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbWcyRGF0YSBUaGUgZGF0YSBvZiB0aGUgc2Vjb25kIGltYWdlIHBhY2tlZCBpbnRvIGEgTm9kZUpTIGJ1ZmZlclxuICogQHBhcmFtIHs/TWF0Y2hpbmdPcHRpb25zfSBvcHRpb25zIFt7fV0gU2V0IG9mIG1hdGNoaW5nIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7TWF0Y2hpbmdSZXN1bHR9IE1hY2hpbmcgcmVzdWx0XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGRldGVjdG9yTmFtZWAgdmFsdWUgaXMgdW5rbm93bi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SW1hZ2VzTWF0Y2hlcyAoaW1nMURhdGEsIGltZzJEYXRhLCBvcHRpb25zID0ge30pIHtcbiAgYXdhaXQgaW5pdE9wZW5DVigpO1xuXG4gIGNvbnN0IHtkZXRlY3Rvck5hbWUgPSAnT1JCJywgdmlzdWFsaXplID0gZmFsc2UsXG4gICAgICAgICBnb29kTWF0Y2hlc0ZhY3RvciwgbWF0Y2hGdW5jID0gJ0JydXRlRm9yY2UnfSA9IG9wdGlvbnM7XG4gIGlmICghXy5pbmNsdWRlcyhBVkFJTEFCTEVfREVURUNUT1JTLCBkZXRlY3Rvck5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHtkZXRlY3Rvck5hbWV9JyBkZXRlY3RvciBpcyB1bmtub3duLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYE9ubHkgJHtKU09OLnN0cmluZ2lmeShBVkFJTEFCTEVfREVURUNUT1JTKX0gZGV0ZWN0b3JzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgaWYgKCFfLmluY2x1ZGVzKEFWQUlMQUJMRV9NQVRDSElOR19GVU5DVElPTlMsIG1hdGNoRnVuYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke21hdGNoRnVuY30nIG1hdGNoaW5nIGZ1bmN0aW9uIGlzIHVua25vd24uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgT25seSAke0pTT04uc3RyaW5naWZ5KEFWQUlMQUJMRV9NQVRDSElOR19GVU5DVElPTlMpfSBtYXRjaGluZyBmdW5jdGlvbnMgYXJlIHN1cHBvcnRlZC5gKTtcbiAgfVxuXG4gIGNvbnN0IGRldGVjdG9yID0gbmV3IGN2W2Ake2RldGVjdG9yTmFtZX1EZXRlY3RvcmBdKCk7XG4gIGNvbnN0IFtpbWcxLCBpbWcyXSA9IGF3YWl0IEIuYWxsKFtcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzFEYXRhKSxcbiAgICBjdi5pbWRlY29kZUFzeW5jKGltZzJEYXRhKVxuICBdKTtcbiAgY29uc3QgW3Jlc3VsdDEsIHJlc3VsdDJdID0gYXdhaXQgQi5hbGwoW1xuICAgIGRldGVjdEFuZENvbXB1dGUoaW1nMSwgZGV0ZWN0b3IpLFxuICAgIGRldGVjdEFuZENvbXB1dGUoaW1nMiwgZGV0ZWN0b3IpXG4gIF0pO1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuICB0cnkge1xuICAgIG1hdGNoZXMgPSBhd2FpdCBjdltgbWF0Y2gke21hdGNoRnVuY31Bc3luY2BdKHJlc3VsdDEuZGVzY3JpcHRvciwgcmVzdWx0Mi5kZXNjcmlwdG9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYW55IG1hdGNoZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gaW1hZ2VzLiBUcnkgYW5vdGhlciBkZXRlY3Rpb24gYWxnb3JpdGhtLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYCBPcmlnaW5hbCBlcnJvcjogJHtlfWApO1xuICB9XG4gIGNvbnN0IHRvdGFsQ291bnQgPSBtYXRjaGVzLmxlbmd0aDtcbiAgaWYgKGhhc1ZhbHVlKGdvb2RNYXRjaGVzRmFjdG9yKSkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oZ29vZE1hdGNoZXNGYWN0b3IpKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZXMgPSBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoLmRpc3RhbmNlKTtcbiAgICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gXy5taW4oZGlzdGFuY2VzKTtcbiAgICAgIGNvbnN0IG1heERpc3RhbmNlID0gXy5tYXgoZGlzdGFuY2VzKTtcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzXG4gICAgICAgIC5maWx0ZXIoKG1hdGNoKSA9PiBnb29kTWF0Y2hlc0ZhY3RvcihtYXRjaC5kaXN0YW5jZSwgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IGdvb2RNYXRjaGVzRmFjdG9yKSB7XG4gICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzXG4gICAgICAgICAgLnNvcnQoKG1hdGNoMSwgbWF0Y2gyKSA9PiBtYXRjaDEuZGlzdGFuY2UgLSBtYXRjaDIuZGlzdGFuY2UpXG4gICAgICAgICAgLnNsaWNlKDAsIGdvb2RNYXRjaGVzRmFjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBleHRyYWN0UG9pbnQgPSAoa2V5UG9pbnRzLCBpbmRleFByb3BlcnR5TmFtZSkgPT4gKG1hdGNoKSA9PiB7XG4gICAgY29uc3Qge3B0LCBwb2ludH0gPSBrZXlQb2ludHNbbWF0Y2hbaW5kZXhQcm9wZXJ0eU5hbWVdXTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanVzdGFkdWRld2hvaGFja3Mvb3BlbmN2NG5vZGVqcy9pc3N1ZXMvNTg0XG4gICAgcmV0dXJuIChwdCB8fCBwb2ludCk7XG4gIH07XG4gIGNvbnN0IHBvaW50czEgPSBtYXRjaGVzLm1hcChleHRyYWN0UG9pbnQocmVzdWx0MS5rZXlQb2ludHMsICdxdWVyeUlkeCcpKTtcbiAgY29uc3QgcmVjdDEgPSBjYWxjdWxhdGVNYXRjaGVkUmVjdChwb2ludHMxKTtcbiAgY29uc3QgcG9pbnRzMiA9IG1hdGNoZXMubWFwKGV4dHJhY3RQb2ludChyZXN1bHQyLmtleVBvaW50cywgJ3RyYWluSWR4JykpO1xuICBjb25zdCByZWN0MiA9IGNhbGN1bGF0ZU1hdGNoZWRSZWN0KHBvaW50czIpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBwb2ludHMxLFxuICAgIHJlY3QxLFxuICAgIHBvaW50czIsXG4gICAgcmVjdDIsXG4gICAgdG90YWxDb3VudCxcbiAgICBjb3VudDogbWF0Y2hlcy5sZW5ndGgsXG4gIH07XG4gIGlmICh2aXN1YWxpemUpIHtcbiAgICBjb25zdCB2aXN1YWxpemF0aW9uID0gY3YuZHJhd01hdGNoZXMoaW1nMSwgaW1nMiwgcmVzdWx0MS5rZXlQb2ludHMsIHJlc3VsdDIua2V5UG9pbnRzLCBtYXRjaGVzKTtcbiAgICBoaWdobGlnaHRSZWdpb24odmlzdWFsaXphdGlvbiwgcmVjdDEpO1xuICAgIGhpZ2hsaWdodFJlZ2lvbih2aXN1YWxpemF0aW9uLCB7XG4gICAgICB4OiBpbWcxLmNvbHMgKyByZWN0Mi54LFxuICAgICAgeTogcmVjdDIueSxcbiAgICAgIHdpZHRoOiByZWN0Mi53aWR0aCxcbiAgICAgIGhlaWdodDogcmVjdDIuaGVpZ2h0XG4gICAgfSk7XG4gICAgcmVzdWx0LnZpc3VhbGl6YXRpb24gPSBhd2FpdCBjdi5pbWVuY29kZUFzeW5jKCcucG5nJywgdmlzdWFsaXphdGlvbik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaW1pbGFyaXR5T3B0aW9uc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gdmlzdWFsaXplIFtmYWxzZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdGluZyB2aXNhbGl6YXRpb25cbiAqIGFzIGFuIGltYWdlICh1c2VmdWwgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbWlsYXJpdHlSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY29yZSBUaGUgc2ltaWxhcml0eSBzY29yZSBhcyBhIGZsb2F0IG51bWJlciBpbiByYW5nZSBbMC4wLCAxLjBdLlxuICogMS4wIGlzIHRoZSBoaWdoZXN0IHNjb3JlIChtZWFucyBib3RoIGltYWdlcyBhcmUgdG90YWxseSBlcXVhbCkuXG4gKiBAcHJvcGVydHkgez9CdWZmZXJ9IHZpc3VhbGl6YXRpb24gVGhlIHZpc3VhbGl6YXRpb24gb2YgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICogcmVwcmVzZW50ZWQgYXMgUE5HIGltYWdlIGJ1ZmZlci4gVGhpcyBpbWFnZSBpbmNsdWRlcyBib3RoIGlucHV0IHBpY3R1cmVzIHdoZXJlXG4gKiBkaWZmZXJlbmNlIHJlZ2lvbnMgYXJlIGhpZ2hsaWdodGVkIHdpdGggcmVjdGFuZ2xlcy5cbiAqL1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNpbWlsYXJpdHkgc2NvcmUgYmV0d2VlbiB0d28gaW1hZ2VzLlxuICogSXQgaXMgZXhwZWN0ZWQsIHRoYXQgYm90aCBpbWFnZXMgaGF2ZSB0aGUgc2FtZSByZXNvbHV0aW9uLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbWcxRGF0YSBUaGUgZGF0YSBvZiB0aGUgZmlyc3QgaW1hZ2UgcGFja2VkIGludG8gYSBOb2RlSlMgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW1nMkRhdGEgVGhlIGRhdGEgb2YgdGhlIHNlY29uZCBpbWFnZSBwYWNrZWQgaW50byBhIE5vZGVKUyBidWZmZXJcbiAqIEBwYXJhbSB7P1NpbWlsYXJpdHlPcHRpb25zfSBvcHRpb25zIFt7fV0gU2V0IG9mIHNpbWlsYXJpdHkgY2FsY3VsYXRpb24gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtTaW1pbGFyaXR5UmVzdWx0fSBUaGUgY2FsY3VsYXRpb24gcmVzdWx0XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGdpdmVuIGltYWdlcyBoYXZlIGRpZmZlcmVudCByZXNvbHV0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZXNTaW1pbGFyaXR5IChpbWcxRGF0YSwgaW1nMkRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICBhd2FpdCBpbml0T3BlbkNWKCk7XG5cbiAgY29uc3Qge3Zpc3VhbGl6ZSA9IGZhbHNlfSA9IG9wdGlvbnM7XG4gIGxldCBbdGVtcGxhdGUsIHJlZmVyZW5jZV0gPSBhd2FpdCBCLmFsbChbXG4gICAgY3YuaW1kZWNvZGVBc3luYyhpbWcxRGF0YSksXG4gICAgY3YuaW1kZWNvZGVBc3luYyhpbWcyRGF0YSlcbiAgXSk7XG4gIGlmICh0ZW1wbGF0ZS5yb3dzICE9PSByZWZlcmVuY2Uucm93cyB8fCB0ZW1wbGF0ZS5jb2xzICE9PSByZWZlcmVuY2UuY29scykge1xuICAgIHRocm93IG5ldyBFcnJvcignQm90aCBpbWFnZXMgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2l6ZSBpbiBvcmRlciB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NhbGN1bGF0ZSB0aGUgc2ltaWxhcml0eSBzY29yZS4nKTtcbiAgfVxuICBbdGVtcGxhdGUsIHJlZmVyZW5jZV0gPSBhd2FpdCBCLmFsbChbXG4gICAgdGVtcGxhdGUuY29udmVydFRvQXN5bmMoY3YuQ1ZfOFVDMyksXG4gICAgcmVmZXJlbmNlLmNvbnZlcnRUb0FzeW5jKGN2LkNWXzhVQzMpXG4gIF0pO1xuXG4gIGNvbnN0IG1hdGNoZWQgPSBhd2FpdCByZWZlcmVuY2UubWF0Y2hUZW1wbGF0ZUFzeW5jKHRlbXBsYXRlLCBjdi5UTV9DQ09FRkZfTk9STUVEKTtcbiAgY29uc3QgbWluTWF4ID0gYXdhaXQgbWF0Y2hlZC5taW5NYXhMb2NBc3luYygpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgc2NvcmU6IG1pbk1heC5tYXhWYWxcbiAgfTtcbiAgaWYgKHZpc3VhbGl6ZSkge1xuICAgIGNvbnN0IHJlc3VsdE1hdCA9IG5ldyBjdi5NYXQodGVtcGxhdGUucm93cywgdGVtcGxhdGUuY29scyAqIDIsIGN2LkNWXzhVQzMpO1xuICAgIGF3YWl0IEIuYWxsKFtcbiAgICAgIHJlZmVyZW5jZS5jb3B5VG9Bc3luYyhcbiAgICAgICAgcmVzdWx0TWF0LmdldFJlZ2lvbihuZXcgY3YuUmVjdCgwLCAwLCByZWZlcmVuY2UuY29scywgcmVmZXJlbmNlLnJvd3MpKSksXG4gICAgICB0ZW1wbGF0ZS5jb3B5VG9Bc3luYyhcbiAgICAgICAgcmVzdWx0TWF0LmdldFJlZ2lvbihuZXcgY3YuUmVjdChyZWZlcmVuY2UuY29scywgMCwgdGVtcGxhdGUuY29scywgdGVtcGxhdGUucm93cykpKVxuICAgIF0pO1xuICAgIGxldCBtYXNrID0gcmVmZXJlbmNlLmFic2RpZmYodGVtcGxhdGUpO1xuICAgIG1hc2sgPSBhd2FpdCBtYXNrLmN2dENvbG9yQXN5bmMoY3YuQ09MT1JfQkdSMkdSQVkpO1xuICAgIGxldCBjb250b3VycyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBtYXNrID0gYXdhaXQgbWFzay50aHJlc2hvbGRBc3luYygxMjgsIDI1NSwgY3YuVEhSRVNIX0JJTkFSWSB8IGN2LlRIUkVTSF9PVFNVKTtcbiAgICAgIGNvbnRvdXJzID0gYXdhaXQgbWFzay5maW5kQ29udG91cnNBc3luYyhjdi5SRVRSX0VYVEVSTkFMLCBjdi5DSEFJTl9BUFBST1hfU0lNUExFKTtcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIC8vIE5vIGNvbnRvdXJzIGNhbiBiZSBmb3VuZCwgd2hpY2ggbWVhbnMsIG1vc3QgbGlrZWx5LCB0aGF0IGltYWdlcyBhcmUgZXF1YWxcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250b3VyIG9mIGNvbnRvdXJzKSB7XG4gICAgICBjb25zdCBib3VuZGluZ1JlY3QgPSBjb250b3VyLmJvdW5kaW5nUmVjdCgpO1xuICAgICAgaGlnaGxpZ2h0UmVnaW9uKHJlc3VsdE1hdCwgYm91bmRpbmdSZWN0KTtcbiAgICAgIGhpZ2hsaWdodFJlZ2lvbihyZXN1bHRNYXQsIHtcbiAgICAgICAgeDogcmVmZXJlbmNlLmNvbHMgKyBib3VuZGluZ1JlY3QueCxcbiAgICAgICAgeTogYm91bmRpbmdSZWN0LnksXG4gICAgICAgIHdpZHRoOiBib3VuZGluZ1JlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3VsdC52aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIHJlc3VsdE1hdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPY2N1cnJlbmNlT3B0aW9uc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gdmlzdWFsaXplIFtmYWxzZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdGluZyB2aXNhbGl6YXRpb25cbiAqIGFzIGFuIGltYWdlICh1c2VmdWwgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcylcbiAqIEBwcm9wZXJ0eSB7P2Zsb2F0fSB0aHJlc2hvbGQgWzAuNV0gQXQgd2hhdCBub3JtYWxpemVkIHRocmVzaG9sZCB0byByZWplY3RcbiAqIGEgbWF0Y2hcbiAqIEBwcm9wZXJ0eSB7P2Zsb2F0fSBtdWx0aXBsZSBbZmFsc2VdIGZpbmQgbXVsdGlwbGUgbWF0Y2hlcyBpbiB0aGUgaW1hZ2VcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gbWF0Y2hOZWlnaGJvdXJUaHJlc2hvbGQgWzEwXSBUaGUgcGl4ZWwgZGlzdGFuY2UgYmV0d2VlbiBtYXRjaGVzIHdlIGNvbnNpZGVyXG4gKiB0byBiZSBwYXJ0IG9mIHRoZSBzYW1lIHRlbXBsYXRlIG1hdGNoXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPY2N1cnJlbmNlUmVzdWx0XG4gKiBAcHJvcGVydHkge1JlY3R9IHJlY3QgVGhlIHJlZ2lvbiBvZiB0aGUgcGFydGlhbCBpbWFnZSBvY2N1cmVuY2VcbiAqIG9uIHRoZSBmdWxsIGltYWdlXG4gKiBAcHJvcGVydHkgez9CdWZmZXJ9IHZpc3VhbGl6YXRpb24gVGhlIHZpc3VhbGl6YXRpb24gb2YgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICogcmVwcmVzZW50ZWQgYXMgUE5HIGltYWdlIGJ1ZmZlci4gT24gdGhpcyBpbWFnZSB0aGUgbWF0Y2hpbmdcbiAqIHJlZ2lvbiBpcyBoaWdobGlnaHRlZCB3aXRoIGEgcmVjdGFuZ2xlLiBJZiB0aGUgbXVsdGlwbGUgb3B0aW9uIGlzIHBhc3NlZCxcbiAqIGFsbCByZXN1bHRzIGFyZSBoaWdobGlnaHRlZCBoZXJlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjb3JlIFRoZSBzaW1pbGFyaXR5IHNjb3JlIGFzIGEgZmxvYXQgbnVtYmVyIGluIHJhbmdlIFswLjAsIDEuMF0uXG4gKiAxLjAgaXMgdGhlIGhpZ2hlc3Qgc2NvcmUgKG1lYW5zIGJvdGggaW1hZ2VzIGFyZSB0b3RhbGx5IGVxdWFsKS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8T2NjdXJyZW5jZVJlc3VsdD59IG11bHRpcGxlIFRoZSBhcnJheSBvZiBtYXRjaGluZyBPY2N1cmVuY2VSZXN1bHRzXG4gKiAtIG9ubHkgd2hlbiBtdWx0aXBsZSBvcHRpb24gaXMgcGFzc2VkXG4gKi9cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBvY2N1cmVuY2UgcG9zaXRpb24gb2YgYSBwYXJ0aWFsIGltYWdlIGluIHRoZSBmdWxsXG4gKiBpbWFnZS5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZnVsbEltZ0RhdGEgVGhlIGRhdGEgb2YgdGhlIGZ1bGwgaW1hZ2UgcGFja2VkIGludG8gYSBOb2RlSlMgYnVmZmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcGFydGlhbEltZ0RhdGEgVGhlIGRhdGEgb2YgdGhlIHBhcnRpYWwgaW1hZ2UgcGFja2VkIGludG8gYSBOb2RlSlMgYnVmZmVyXG4gKiBAcGFyYW0gez9PY2N1cnJlbmNlT3B0aW9uc30gb3B0aW9ucyBbe31dIFNldCBvZiBvY2N1cnJlbmNlIGNhbGN1bGF0aW9uIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7T2NjdXJyZW5jZVJlc3VsdH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBvY2N1cmVuY2VzIG9mIHRoZSBwYXJ0aWFsIGltYWdlIGNhbiBiZSBmb3VuZCBpbiB0aGUgZnVsbCBpbWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRJbWFnZU9jY3VycmVuY2UgKGZ1bGxJbWdEYXRhLCBwYXJ0aWFsSW1nRGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gIGF3YWl0IGluaXRPcGVuQ1YoKTtcblxuICBjb25zdCB7IHZpc3VhbGl6ZSA9IGZhbHNlLFxuICAgICAgICAgIHRocmVzaG9sZCA9IERFRkFVTFRfTUFUQ0hfVEhSRVNIT0xELFxuICAgICAgICAgIG11bHRpcGxlID0gZmFsc2UsXG4gICAgICAgICAgbWF0Y2hOZWlnaGJvdXJUaHJlc2hvbGQgPSBNQVRDSF9ORUlHSEJPVVJfVEhSRVNIT0xEIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IFtmdWxsSW1nLCBwYXJ0aWFsSW1nXSA9IGF3YWl0IEIuYWxsKFtcbiAgICBjdi5pbWRlY29kZUFzeW5jKGZ1bGxJbWdEYXRhKSxcbiAgICBjdi5pbWRlY29kZUFzeW5jKHBhcnRpYWxJbWdEYXRhKVxuICBdKTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBsZXQgdmlzdWFsaXphdGlvbiA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBtYXRjaGVkID0gYXdhaXQgZnVsbEltZy5tYXRjaFRlbXBsYXRlQXN5bmMocGFydGlhbEltZywgY3YuVE1fQ0NPRUZGX05PUk1FRCk7XG4gICAgY29uc3QgbWluTWF4ID0gYXdhaXQgbWF0Y2hlZC5taW5NYXhMb2NBc3luYygpO1xuXG4gICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICBjb25zdCBub25aZXJvTWF0Y2hSZXN1bHRzID0gbWF0Y2hlZC50aHJlc2hvbGQodGhyZXNob2xkLCAxLCBjdi5USFJFU0hfQklOQVJZKS5jb252ZXJ0VG8oY3YuQ1ZfOFUpLmZpbmROb25aZXJvKCk7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZmlsdGVyTmVhck1hdGNoZXMobm9uWmVyb01hdGNoUmVzdWx0cywgbWF0Y2hOZWlnaGJvdXJUaHJlc2hvbGQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgbWF0Y2hlcykge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIHNjb3JlOiBtYXRjaGVkLmF0KGVsZW1lbnQueSwgZWxlbWVudC54KSxcbiAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICB4OiBlbGVtZW50LngsXG4gICAgICAgICAgICB5OiBlbGVtZW50LnksXG4gICAgICAgICAgICB3aWR0aDogcGFydGlhbEltZy5jb2xzLFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJ0aWFsSW1nLnJvd3NcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluTWF4Lm1heFZhbCA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIHNjb3JlOiBtaW5NYXgubWF4VmFsLFxuICAgICAgICByZWN0OiB7XG4gICAgICAgICAgeDogbWluTWF4Lm1heExvYy54LFxuICAgICAgICAgIHk6IG1pbk1heC5tYXhMb2MueSxcbiAgICAgICAgICB3aWR0aDogcGFydGlhbEltZy5jb2xzLFxuICAgICAgICAgIGhlaWdodDogcGFydGlhbEltZy5yb3dzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChfLmlzRW1wdHkocmVzdWx0cykpIHtcbiAgICAgIC8vIEJlbG93IGVycm9yIG1lc3NhZ2UsIGBDYW5ub3QgZmluZCBhbnkgb2NjdXJyZW5jZXNgIGlzIHJlZmVyZW5jZWQgaW4gZmluZCBieSBpbWFnZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXRjaCB0aHJlc2hvbGQ6ICR7dGhyZXNob2xkfS4gSGlnaGVzdCBtYXRjaCB2YWx1ZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgZm91bmQgd2FzICR7bWluTWF4Lm1heFZhbH1gKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBCZWxvdyBlcnJvciBtZXNzYWdlLCBgQ2Fubm90IGZpbmQgYW55IG9jY3VycmVuY2VzYCBpcyByZWZlcmVuY2VkIGluIGZpbmQgYnkgaW1hZ2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIGFueSBvY2N1cnJlbmNlcyBvZiB0aGUgcGFydGlhbCBpbWFnZSBpbiB0aGUgZnVsbCBpbWFnZS4gYCArXG4gICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG5cbiAgaWYgKHZpc3VhbGl6ZSkge1xuICAgIGNvbnN0IGZ1bGxIaWdobGlnaHRlZEltYWdlID0gZnVsbEltZy5jb3B5KCk7XG5cbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICBjb25zdCBzaW5nbGVIaWdobGlnaHRlZEltYWdlID0gZnVsbEltZy5jb3B5KCk7XG5cbiAgICAgIGhpZ2hsaWdodFJlZ2lvbihzaW5nbGVIaWdobGlnaHRlZEltYWdlLCByZXN1bHQucmVjdCk7XG4gICAgICBoaWdobGlnaHRSZWdpb24oZnVsbEhpZ2hsaWdodGVkSW1hZ2UsIHJlc3VsdC5yZWN0KTtcbiAgICAgIHJlc3VsdC52aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIHNpbmdsZUhpZ2hsaWdodGVkSW1hZ2UpO1xuICAgIH1cbiAgICB2aXN1YWxpemF0aW9uID0gYXdhaXQgY3YuaW1lbmNvZGVBc3luYygnLnBuZycsIGZ1bGxIaWdobGlnaHRlZEltYWdlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVjdDogcmVzdWx0c1swXS5yZWN0LFxuICAgIHNjb3JlOiByZXN1bHRzWzBdLnNjb3JlLFxuICAgIHZpc3VhbGl6YXRpb24sXG4gICAgbXVsdGlwbGU6IHJlc3VsdHNcbiAgfTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgb3V0IG1hdGNoIHJlc3VsdHMgd2hpY2ggaGF2ZSBhIG1hdGNoZWQgbmVpZ2hib3VyXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IG5vblplcm9NYXRjaFJlc3VsdHMgbWF0cml4IG9mIGltYWdlIG1hdGNoIHJlc3VsdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXRjaE5laWdoYm91clRocmVzaG9sZCBUaGUgcGl4ZWwgZGlzdGFuY2Ugd2l0aGluIHdoaWNoIHdlXG4gKiBjb25zaWRlciBhbiBlbGVtZW50IGJlaW5nIGEgbmVpZ2hib3VyIG9mIGFuIGV4aXN0aW5nIG1hdGNoXG4gKiBAcmV0dXJuIHtBcnJheTxQb2ludD59IHRoZSBmaWx0ZXJlZCBhcnJheSBvZiBtYXRjaGVkIHBvaW50c1xuICovXG5mdW5jdGlvbiBmaWx0ZXJOZWFyTWF0Y2hlcyAobm9uWmVyb01hdGNoUmVzdWx0cywgbWF0Y2hOZWlnaGJvdXJUaHJlc2hvbGQpIHtcbiAgcmV0dXJuIG5vblplcm9NYXRjaFJlc3VsdHMucmVkdWNlKChhY2MsIGVsZW1lbnQpID0+IHtcbiAgICBpZiAoIWFjYy5zb21lKChtYXRjaCkgPT4gZGlzdGFuY2UobWF0Y2gsIGVsZW1lbnQpIDw9IG1hdGNoTmVpZ2hib3VyVGhyZXNob2xkKSkge1xuICAgICAgYWNjLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludDEgVGhlIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0ge1BvaW50fSBwb2ludDIgVGhlIHNlY29uZCBwb2ludFxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UgKHBvaW50MSwgcG9pbnQyKSB7XG4gIGNvbnN0IGEyID0gTWF0aC5wb3coKHBvaW50MS54IC0gcG9pbnQyLngpLCAyKTtcbiAgY29uc3QgYjIgPSBNYXRoLnBvdygocG9pbnQxLnkgLSBwb2ludDIueSksIDIpO1xuICByZXR1cm4gTWF0aC5zcXJ0KGEyICsgYjIpO1xufVxuXG4vKipcbiAqIENyb3AgdGhlIGltYWdlIGJ5IGdpdmVuIHJlY3RhbmdsZSAodXNlIGJhc2U2NCBzdHJpbmcgYXMgaW5wdXQgYW5kIG91dHB1dClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0SW1hZ2UgVGhlIHN0cmluZyB3aXRoIGJhc2U2NCBlbmNvZGVkIGltYWdlXG4gKiBAcGFyYW0ge1JlZ2lvbn0gcmVjdCBUaGUgc2VsZWN0ZWQgcmVnaW9uIG9mIGltYWdlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiBjcm9wcGVkIGltYWdlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyb3BCYXNlNjRJbWFnZSAoYmFzZTY0SW1hZ2UsIHJlY3QpIHtcbiAgY29uc3QgaW1hZ2UgPSBhd2FpdCBiYXNlNjRUb0ltYWdlKGJhc2U2NEltYWdlKTtcbiAgY3JvcEltYWdlKGltYWdlLCByZWN0KTtcbiAgcmV0dXJuIGF3YWl0IGltYWdlVG9CYXNlNjQoaW1hZ2UpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBuZ2pzIGltYWdlIGZyb20gZ2l2ZW4gYmFzZTY0IGltYWdlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NEltYWdlIFRoZSBzdHJpbmcgd2l0aCBiYXNlNjQgZW5jb2RlZCBpbWFnZVxuICogQHJldHVybiB7UE5HfSBUaGUgaW1hZ2Ugb2JqZWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJhc2U2NFRvSW1hZ2UgKGJhc2U2NEltYWdlKSB7XG4gIGNvbnN0IGltYWdlQnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0SW1hZ2UsICdiYXNlNjQnKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBQTkcoe2ZpbHRlclR5cGU6IFNDQU5MSU5FX0ZJTFRFUl9NRVRIT0R9KTtcbiAgICBpbWFnZS5wYXJzZShpbWFnZUJ1ZmZlciwgKGVyciwgaW1hZ2UpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by1jYWxsYmFja3NcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGJhc2U2NCBzdHJpbmcgZm9yIGdpdmVuIGltYWdlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7UE5HfSBpbWFnZSBUaGUgaW1hZ2Ugb2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgd2l0aCBiYXNlNjQgZW5jb2RlZCBpbWFnZVxuICovXG5hc3luYyBmdW5jdGlvbiBpbWFnZVRvQmFzZTY0IChpbWFnZSkge1xuICByZXR1cm4gYXdhaXQgbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGltYWdlLnBhY2soKVxuICAgIC5vbignZGF0YScsIChjaHVuaykgPT4gY2h1bmtzLnB1c2goY2h1bmspKS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KGNodW5rcykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCAoZXJyKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JvcCB0aGUgaW1hZ2UgYnkgZ2l2ZW4gcmVjdGFuZ2xlXG4gKlxuICogQHBhcmFtIHtQTkd9IGltYWdlIFRoZSBpbWFnZSB0byBtdXRhdGUgYnkgY3JvcHBpbmdcbiAqIEBwYXJhbSB7UmVnaW9ufSByZWN0IFRoZSBzZWxlY3RlZCByZWdpb24gb2YgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gY3JvcEltYWdlIChpbWFnZSwgcmVjdCkge1xuICBjb25zdCBpbWFnZVJlY3QgPSB7d2lkdGg6IGltYWdlLndpZHRoLCBoZWlnaHQ6IGltYWdlLmhlaWdodH07XG4gIGNvbnN0IGludGVyUmVjdCA9IGdldFJlY3RJbnRlcnNlY3Rpb24ocmVjdCwgaW1hZ2VSZWN0KTtcbiAgaWYgKGludGVyUmVjdC53aWR0aCA8IHJlY3Qud2lkdGggfHwgaW50ZXJSZWN0LmhlaWdodCA8IHJlY3QuaGVpZ2h0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JvcCAke0pTT04uc3RyaW5naWZ5KHJlY3QpfSBmcm9tICR7SlNPTi5zdHJpbmdpZnkoaW1hZ2VSZWN0KX0gYmVjYXVzZSB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlbSB3YXMgbm90IHRoZSBzaXplIG9mIHRoZSByZWN0YCk7XG4gIH1cblxuICBjb25zdCBmaXJzdFZlcnRpY2FsUGl4ZWwgPSBpbnRlclJlY3QudG9wO1xuICBjb25zdCBsYXN0VmVydGljYWxQaXhlbCA9IGludGVyUmVjdC50b3AgKyBpbnRlclJlY3QuaGVpZ2h0O1xuXG4gIGNvbnN0IGZpcnN0SG9yaXpvbnRhbFBpeGVsID0gaW50ZXJSZWN0LmxlZnQ7XG4gIGNvbnN0IGxhc3RIb3Jpem9udGFsUGl4ZWwgPSBpbnRlclJlY3QubGVmdCArIGludGVyUmVjdC53aWR0aDtcblxuICBjb25zdCBjcm9wcGVkQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgeSA9IGZpcnN0VmVydGljYWxQaXhlbDsgeSA8IGxhc3RWZXJ0aWNhbFBpeGVsOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gZmlyc3RIb3Jpem9udGFsUGl4ZWw7IHggPCBsYXN0SG9yaXpvbnRhbFBpeGVsOyB4KyspIHtcbiAgICAgIGNvbnN0IGZpcnN0Qnl0ZUlkeEluUGl4ZWxCbG9jayA9IChpbWFnZVJlY3Qud2lkdGggKiB5ICsgeCkgPDwgMjtcbiAgICAgIGZvciAobGV0IGJ5dGVJZHggPSAwOyBieXRlSWR4IDwgQllURVNfSU5fUElYRUxfQkxPQ0s7IGJ5dGVJZHgrKykge1xuICAgICAgICBjcm9wcGVkQXJyYXkucHVzaChpbWFnZS5kYXRhW2ZpcnN0Qnl0ZUlkeEluUGl4ZWxCbG9jayArIGJ5dGVJZHhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbWFnZS5kYXRhID0gQnVmZmVyLmZyb20oY3JvcHBlZEFycmF5KTtcbiAgaW1hZ2Uud2lkdGggPSBpbnRlclJlY3Qud2lkdGg7XG4gIGltYWdlLmhlaWdodCA9IGludGVyUmVjdC5oZWlnaHQ7XG4gIHJldHVybiBpbWFnZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdEludGVyc2VjdGlvbiAocmVjdCwgaW1hZ2VTaXplKSB7XG4gIGNvbnN0IGxlZnQgPSByZWN0LmxlZnQgPj0gaW1hZ2VTaXplLndpZHRoID8gaW1hZ2VTaXplLndpZHRoIDogcmVjdC5sZWZ0O1xuICBjb25zdCB0b3AgPSByZWN0LnRvcCA+PSBpbWFnZVNpemUuaGVpZ2h0ID8gaW1hZ2VTaXplLmhlaWdodCA6IHJlY3QudG9wO1xuICBjb25zdCB3aWR0aCA9IGltYWdlU2l6ZS53aWR0aCA+PSAobGVmdCArIHJlY3Qud2lkdGgpID8gcmVjdC53aWR0aCA6IChpbWFnZVNpemUud2lkdGggLSBsZWZ0KTtcbiAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VTaXplLmhlaWdodCA+PSAodG9wICsgcmVjdC5oZWlnaHQpID8gcmVjdC5oZWlnaHQgOiAoaW1hZ2VTaXplLmhlaWdodCAtIHRvcCk7XG4gIHJldHVybiB7bGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fTtcbn1cblxuZXhwb3J0IHtcbiAgY3JvcEJhc2U2NEltYWdlLCBiYXNlNjRUb0ltYWdlLCBpbWFnZVRvQmFzZTY0LCBjcm9wSW1hZ2UsIGdldEltYWdlc01hdGNoZXMsXG4gIGdldEltYWdlc1NpbWlsYXJpdHksIGdldEltYWdlT2NjdXJyZW5jZSwgZ2V0SmltcEltYWdlLCBNSU1FX0pQRUcsIE1JTUVfUE5HLFxuICBNSU1FX0JNUCxcbn07XG4iXSwiZmlsZSI6ImxpYi9pbWFnZS11dGlsLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
