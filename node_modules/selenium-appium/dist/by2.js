/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.By2 = void 0;
// eslint-disable-next-line import/no-unresolved
const selenium_webdriver_1 = require("selenium-webdriver");
const Driver_1 = require("./Driver");
const Config_1 = require("./Config");
class By2 {
    constructor(using, value, webDriver2) {
        this.using = using;
        this.value = value;
        this.webDriver2_ = webDriver2;
    }
    toString() {
        // The static By.name() overrides this.constructor.name.  Shame...
        return `By2(${this.using}, ${this.value}, ${this.webDriver2_})`;
    }
    get webElement() {
        const webDriver = this.webDriver2_ ? this.webDriver2_ : Driver_1.driver;
        try {
            return webDriver.wait(selenium_webdriver_1.until.elementLocated(this), Config_1.Config.getWaitForTimeout(), 'Timeout in By2: ' + this.toString());
        }
        catch (e) {
            return new selenium_webdriver_1.WebElementPromise(webDriver, Promise.reject(e));
        }
    }
    getDriver() {
        return this.webElement.getDriver();
    }
    getId() {
        return this.webElement.getId();
    }
    findElement(locator) {
        return this.webElement.findElement(locator);
    }
    findElements(locator) {
        return this.webElement.findElements(locator);
    }
    click() {
        return this.webElement.click();
    }
    sendKeys(...var_args) {
        return this.webElement.sendKeys(...var_args);
    }
    getTagName() {
        return this.webElement.getTagName();
    }
    getCssValue(cssStyleProperty) {
        return this.webElement.getCssValue(cssStyleProperty);
    }
    getAttribute(attributeName) {
        return this.webElement.getAttribute(attributeName);
    }
    getText() {
        return this.webElement.getText();
    }
    getSize() {
        return this.webElement.getSize();
    }
    getRect() {
        return this.webElement.getRect();
    }
    getLocation() {
        return this.webElement.getLocation();
    }
    isEnabled() {
        return this.webElement.isEnabled();
    }
    isSelected() {
        return this.webElement.isSelected();
    }
    submit() {
        return this.webElement.submit();
    }
    clear() {
        return this.webElement.clear();
    }
    isDisplayed() {
        return this.webElement.isDisplayed();
    }
    takeScreenshot(opt_scroll) {
        return this.webElement.takeScreenshot(opt_scroll);
    }
    serialize() {
        return this.webElement.serialize();
    }
    /**
     * Locates elements that have a specific class name.
     *
     * @param {string} name The class name to search for.
     * @return {!By} The new locator.
     * @see http://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes
     * @see http://www.w3.org/TR/CSS2/selector.html#class-html
     */
    static className(name, webDriver2) {
        return By2.from(selenium_webdriver_1.By.className(name), webDriver2);
    }
    /**
     * Locates elements using a CSS selector.
     *
     * @param {string} selector The CSS selector to use.
     * @return {!By} The new locator.
     * @see http://www.w3.org/TR/CSS2/selector.html
     */
    static css(selector, webDriver2) {
        return By2.from(selenium_webdriver_1.By.css(selector), webDriver2);
    }
    /**
     * Locates eleemnts by the ID attribute. This locator uses the CSS selector
     * `*[id='$ID']`, _not_ `document.getElementById`.
     *
     * @param {string} id The ID to search for.
     * @return {!By} The new locator.
     */
    static id(id, webDriver2) {
        return By2.from(selenium_webdriver_1.By.id(id), webDriver2);
    }
    /**
     * Locates link elements whose
     * {@linkplain WebElement#getText visible text} matches the given
     * string.
     *
     * @param {string} text The link text to search for.
     * @return {!By} The new locator.
     */
    static linkText(text, webDriver2) {
        return By2.from(selenium_webdriver_1.By.linkText(text), webDriver2);
    }
    /**
     * Locates elements whose `name` attribute has the given value. This locator uses the CSS selector
     *
     * @param {string} name The name attribute to search for.
     * @return {!By} The new locator.
     */
    static name2(name, webDriver2) {
        return By2.from(selenium_webdriver_1.By.name(name), webDriver2);
    }
    /**
     * Locates link elements whose
     * {@linkplain WebElement#getText visible text} contains the given
     * substring.
     *
     * @param {string} text The substring to check for in a link's visible text.
     * @return {!By} The new locator.
     */
    static partialLinkText(text, webDriver2) {
        return By2.from(selenium_webdriver_1.By.partialLinkText(text), webDriver2);
    }
    /**
     * Locates elements with a given tag name. This locator uses the CSS selector
     *
     * @param {string} name The tag name to search for.
     * @return {!By} The new locator.
     * @deprecated Use {@link By.css() By.css(tagName)} instead.
     */
    static tagName(name, webDriver2) {
        return By2.from(selenium_webdriver_1.By.tagName(name), webDriver2);
    }
    /**
     * Locates elements matching a XPath selector. Care should be taken when
     * using an XPath selector with a {@link WebElement} as WebDriver
     * will respect the context in the specified in the selector. For example,
     * given the selector `//div`, WebDriver will search from the document root
     * regardless of whether the locator was used with a WebElement.
     *
     * @param {string} xpath The XPath selector to use.
     * @return {!By} The new locator.
     * @see http://www.w3.org/TR/xpath/
     */
    static xpath(xpath, webDriver2) {
        return By2.from(selenium_webdriver_1.By.xpath(xpath), webDriver2);
    }
    static from(by, webDriver2) {
        return new By2(by.using, by.value, webDriver2);
    }
    /**
     * "using": "name", only for WinAppDriver
     * @param name
     * @param webDriver2
     */
    static nativeName(name, webDriver2) {
        return new By2('name', name, webDriver2);
    }
    /**
     * "using": "class name"
     * @see https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md#locator-strategies
     * @param className
     * @param webDriver2
     */
    static nativeClassName(className, webDriver2) {
        return new By2('class name', className, webDriver2);
    }
    /**
     * "using": "accessibility id"
     * @see https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md#locator-strategies
     * @param accessibilityId
     * @param webDriver2
     */
    static nativeAccessibilityId(accessibilityId, webDriver2) {
        return new By2('accessibility id', accessibilityId, webDriver2);
    }
    /**
     * "using": "xpath"
     * @see https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md#locator-strategies
     * @param xpath
     * @param webDriver2
     */
    static nativeXpath(xpath, webDriver2) {
        return new By2('xpath', xpath, webDriver2);
    }
    /**
     * "using": "id"
     * @see https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md#locator-strategies
     * @param id
     * @param webDriver2
     */
    static nativeId(id, webDriver2) {
        return new By2('id', id, webDriver2);
    }
    /**
     * "using": "-android uiautomator"
     * @see https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md#locator-strategies
     * @param uiautomator
     * @param webDriver2
     */
    static nativeAndriod(uiautomator, webDriver2) {
        return new By2('-android uiautomator', uiautomator, webDriver2);
    }
    /** "using": "-ios uiautomator"
     * @see https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md#locator-strategies
     * @param uiautomator
     * @param webDriver2
     */
    static nativeIos(uiautomator, webDriver2) {
        return new By2('-ios uiautomation', uiautomator, webDriver2);
    }
}
exports.By2 = By2;
//# sourceMappingURL=by2.js.map